// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package storetest

import (
	"context"
	"github.com/ONSdigital/dp-dataset-api/models"
	"github.com/ONSdigital/dp-dataset-api/store"
	"github.com/ONSdigital/dp-healthcheck/healthcheck"
	"github.com/globalsign/mgo/bson"
	"sync"
)

var (
	lockMongoDBMockAcquireInstanceLock               sync.RWMutex
	lockMongoDBMockAddDimensionToInstance            sync.RWMutex
	lockMongoDBMockAddEventToInstance                sync.RWMutex
	lockMongoDBMockAddInstance                       sync.RWMutex
	lockMongoDBMockCheckDatasetExists                sync.RWMutex
	lockMongoDBMockCheckEditionExists                sync.RWMutex
	lockMongoDBMockChecker                           sync.RWMutex
	lockMongoDBMockClose                             sync.RWMutex
	lockMongoDBMockDeleteDataset                     sync.RWMutex
	lockMongoDBMockDeleteEdition                     sync.RWMutex
	lockMongoDBMockGetDataset                        sync.RWMutex
	lockMongoDBMockGetDatasets                       sync.RWMutex
	lockMongoDBMockGetDimensionOptions               sync.RWMutex
	lockMongoDBMockGetDimensionOptionsFromIDs        sync.RWMutex
	lockMongoDBMockGetDimensions                     sync.RWMutex
	lockMongoDBMockGetDimensionsFromInstance         sync.RWMutex
	lockMongoDBMockGetEdition                        sync.RWMutex
	lockMongoDBMockGetEditions                       sync.RWMutex
	lockMongoDBMockGetInstance                       sync.RWMutex
	lockMongoDBMockGetInstances                      sync.RWMutex
	lockMongoDBMockGetNextVersion                    sync.RWMutex
	lockMongoDBMockGetUniqueDimensionAndOptions      sync.RWMutex
	lockMongoDBMockGetVersion                        sync.RWMutex
	lockMongoDBMockGetVersions                       sync.RWMutex
	lockMongoDBMockUnlockInstance                    sync.RWMutex
	lockMongoDBMockUpdateBuildHierarchyTaskState     sync.RWMutex
	lockMongoDBMockUpdateBuildSearchTaskState        sync.RWMutex
	lockMongoDBMockUpdateDataset                     sync.RWMutex
	lockMongoDBMockUpdateDatasetWithAssociation      sync.RWMutex
	lockMongoDBMockUpdateDimensionNodeIDAndOrder     sync.RWMutex
	lockMongoDBMockUpdateETagForNodeIDAndOrder       sync.RWMutex
	lockMongoDBMockUpdateETagForOptions              sync.RWMutex
	lockMongoDBMockUpdateImportObservationsTaskState sync.RWMutex
	lockMongoDBMockUpdateInstance                    sync.RWMutex
	lockMongoDBMockUpdateObservationInserted         sync.RWMutex
	lockMongoDBMockUpdateVersion                     sync.RWMutex
	lockMongoDBMockUpsertContact                     sync.RWMutex
	lockMongoDBMockUpsertDataset                     sync.RWMutex
	lockMongoDBMockUpsertEdition                     sync.RWMutex
	lockMongoDBMockUpsertVersion                     sync.RWMutex
)

// Ensure, that MongoDBMock does implement store.MongoDB.
// If this is not the case, regenerate this file with moq.
var _ store.MongoDB = &MongoDBMock{}

// MongoDBMock is a mock implementation of store.MongoDB.
//
//     func TestSomethingThatUsesMongoDB(t *testing.T) {
//
//         // make and configure a mocked store.MongoDB
//         mockedMongoDB := &MongoDBMock{
//             AcquireInstanceLockFunc: func(ctx context.Context, instanceID string) (string, error) {
// 	               panic("mock out the AcquireInstanceLock method")
//             },
//             AddDimensionToInstanceFunc: func(dimension *models.CachedDimensionOption) error {
// 	               panic("mock out the AddDimensionToInstance method")
//             },
//             AddEventToInstanceFunc: func(currentInstance *models.Instance, event *models.Event, eTagSelector string) (string, error) {
// 	               panic("mock out the AddEventToInstance method")
//             },
//             AddInstanceFunc: func(instance *models.Instance) (*models.Instance, error) {
// 	               panic("mock out the AddInstance method")
//             },
//             CheckDatasetExistsFunc: func(ID string, state string) error {
// 	               panic("mock out the CheckDatasetExists method")
//             },
//             CheckEditionExistsFunc: func(ID string, editionID string, state string) error {
// 	               panic("mock out the CheckEditionExists method")
//             },
//             CheckerFunc: func(in1 context.Context, in2 *healthcheck.CheckState) error {
// 	               panic("mock out the Checker method")
//             },
//             CloseFunc: func(in1 context.Context) error {
// 	               panic("mock out the Close method")
//             },
//             DeleteDatasetFunc: func(ID string) error {
// 	               panic("mock out the DeleteDataset method")
//             },
//             DeleteEditionFunc: func(ID string) error {
// 	               panic("mock out the DeleteEdition method")
//             },
//             GetDatasetFunc: func(ID string) (*models.DatasetUpdate, error) {
// 	               panic("mock out the GetDataset method")
//             },
//             GetDatasetsFunc: func(ctx context.Context, offset int, limit int, authorised bool) ([]*models.DatasetUpdate, int, error) {
// 	               panic("mock out the GetDatasets method")
//             },
//             GetDimensionOptionsFunc: func(ctx context.Context, version *models.Version, dimension string, offset int, limit int) ([]*models.PublicDimensionOption, int, error) {
// 	               panic("mock out the GetDimensionOptions method")
//             },
//             GetDimensionOptionsFromIDsFunc: func(version *models.Version, dimension string, ids []string) ([]*models.PublicDimensionOption, int, error) {
// 	               panic("mock out the GetDimensionOptionsFromIDs method")
//             },
//             GetDimensionsFunc: func(datasetID string, versionID string) ([]bson.M, error) {
// 	               panic("mock out the GetDimensions method")
//             },
//             GetDimensionsFromInstanceFunc: func(ctx context.Context, ID string, offset int, limit int) ([]*models.DimensionOption, int, error) {
// 	               panic("mock out the GetDimensionsFromInstance method")
//             },
//             GetEditionFunc: func(ID string, editionID string, state string) (*models.EditionUpdate, error) {
// 	               panic("mock out the GetEdition method")
//             },
//             GetEditionsFunc: func(ctx context.Context, ID string, state string, offset int, limit int, authorised bool) ([]*models.EditionUpdate, int, error) {
// 	               panic("mock out the GetEditions method")
//             },
//             GetInstanceFunc: func(ID string, eTagSelector string) (*models.Instance, error) {
// 	               panic("mock out the GetInstance method")
//             },
//             GetInstancesFunc: func(ctx context.Context, states []string, datasets []string, offset int, limit int) ([]*models.Instance, int, error) {
// 	               panic("mock out the GetInstances method")
//             },
//             GetNextVersionFunc: func(datasetID string, editionID string) (int, error) {
// 	               panic("mock out the GetNextVersion method")
//             },
//             GetUniqueDimensionAndOptionsFunc: func(ctx context.Context, ID string, dimension string, offset int, limit int) ([]*string, int, error) {
// 	               panic("mock out the GetUniqueDimensionAndOptions method")
//             },
//             GetVersionFunc: func(datasetID string, editionID string, version int, state string) (*models.Version, error) {
// 	               panic("mock out the GetVersion method")
//             },
//             GetVersionsFunc: func(ctx context.Context, datasetID string, editionID string, state string, offset int, limit int) ([]models.Version, int, error) {
// 	               panic("mock out the GetVersions method")
//             },
//             UnlockInstanceFunc: func(lockID string) error {
// 	               panic("mock out the UnlockInstance method")
//             },
//             UpdateBuildHierarchyTaskStateFunc: func(currentInstance *models.Instance, dimension string, state string, eTagSelector string) (string, error) {
// 	               panic("mock out the UpdateBuildHierarchyTaskState method")
//             },
//             UpdateBuildSearchTaskStateFunc: func(currentInstance *models.Instance, dimension string, state string, eTagSelector string) (string, error) {
// 	               panic("mock out the UpdateBuildSearchTaskState method")
//             },
//             UpdateDatasetFunc: func(ctx context.Context, ID string, dataset *models.Dataset, currentState string) error {
// 	               panic("mock out the UpdateDataset method")
//             },
//             UpdateDatasetWithAssociationFunc: func(ID string, state string, version *models.Version) error {
// 	               panic("mock out the UpdateDatasetWithAssociation method")
//             },
//             UpdateDimensionNodeIDAndOrderFunc: func(dimension *models.DimensionOption) error {
// 	               panic("mock out the UpdateDimensionNodeIDAndOrder method")
//             },
//             UpdateETagForNodeIDAndOrderFunc: func(currentInstance *models.Instance, nodeID string, order *int, eTagSelector string) (string, error) {
// 	               panic("mock out the UpdateETagForNodeIDAndOrder method")
//             },
//             UpdateETagForOptionsFunc: func(currentInstance *models.Instance, option *models.CachedDimensionOption, eTagSelector string) (string, error) {
// 	               panic("mock out the UpdateETagForOptions method")
//             },
//             UpdateImportObservationsTaskStateFunc: func(currentInstance *models.Instance, state string, eTagSelector string) (string, error) {
// 	               panic("mock out the UpdateImportObservationsTaskState method")
//             },
//             UpdateInstanceFunc: func(ctx context.Context, currentInstance *models.Instance, updatedInstance *models.Instance, eTagSelector string) (string, error) {
// 	               panic("mock out the UpdateInstance method")
//             },
//             UpdateObservationInsertedFunc: func(currentInstance *models.Instance, observationInserted int64, eTagSelector string) (string, error) {
// 	               panic("mock out the UpdateObservationInserted method")
//             },
//             UpdateVersionFunc: func(ID string, version *models.Version) error {
// 	               panic("mock out the UpdateVersion method")
//             },
//             UpsertContactFunc: func(ID string, update interface{}) error {
// 	               panic("mock out the UpsertContact method")
//             },
//             UpsertDatasetFunc: func(ID string, datasetDoc *models.DatasetUpdate) error {
// 	               panic("mock out the UpsertDataset method")
//             },
//             UpsertEditionFunc: func(datasetID string, edition string, editionDoc *models.EditionUpdate) error {
// 	               panic("mock out the UpsertEdition method")
//             },
//             UpsertVersionFunc: func(ID string, versionDoc *models.Version) error {
// 	               panic("mock out the UpsertVersion method")
//             },
//         }
//
//         // use mockedMongoDB in code that requires store.MongoDB
//         // and then make assertions.
//
//     }
type MongoDBMock struct {
	// AcquireInstanceLockFunc mocks the AcquireInstanceLock method.
	AcquireInstanceLockFunc func(ctx context.Context, instanceID string) (string, error)

	// AddDimensionToInstanceFunc mocks the AddDimensionToInstance method.
	AddDimensionToInstanceFunc func(dimension *models.CachedDimensionOption) error

	// AddEventToInstanceFunc mocks the AddEventToInstance method.
	AddEventToInstanceFunc func(currentInstance *models.Instance, event *models.Event, eTagSelector string) (string, error)

	// AddInstanceFunc mocks the AddInstance method.
	AddInstanceFunc func(instance *models.Instance) (*models.Instance, error)

	// CheckDatasetExistsFunc mocks the CheckDatasetExists method.
	CheckDatasetExistsFunc func(ID string, state string) error

	// CheckEditionExistsFunc mocks the CheckEditionExists method.
	CheckEditionExistsFunc func(ID string, editionID string, state string) error

	// CheckerFunc mocks the Checker method.
	CheckerFunc func(in1 context.Context, in2 *healthcheck.CheckState) error

	// CloseFunc mocks the Close method.
	CloseFunc func(in1 context.Context) error

	// DeleteDatasetFunc mocks the DeleteDataset method.
	DeleteDatasetFunc func(ID string) error

	// DeleteEditionFunc mocks the DeleteEdition method.
	DeleteEditionFunc func(ID string) error

	// GetDatasetFunc mocks the GetDataset method.
	GetDatasetFunc func(ID string) (*models.DatasetUpdate, error)

	// GetDatasetsFunc mocks the GetDatasets method.
	GetDatasetsFunc func(ctx context.Context, offset int, limit int, authorised bool) ([]*models.DatasetUpdate, int, error)

	// GetDimensionOptionsFunc mocks the GetDimensionOptions method.
	GetDimensionOptionsFunc func(ctx context.Context, version *models.Version, dimension string, offset int, limit int) ([]*models.PublicDimensionOption, int, error)

	// GetDimensionOptionsFromIDsFunc mocks the GetDimensionOptionsFromIDs method.
	GetDimensionOptionsFromIDsFunc func(version *models.Version, dimension string, ids []string) ([]*models.PublicDimensionOption, int, error)

	// GetDimensionsFunc mocks the GetDimensions method.
	GetDimensionsFunc func(datasetID string, versionID string) ([]bson.M, error)

	// GetDimensionsFromInstanceFunc mocks the GetDimensionsFromInstance method.
	GetDimensionsFromInstanceFunc func(ctx context.Context, ID string, offset int, limit int) ([]*models.DimensionOption, int, error)

	// GetEditionFunc mocks the GetEdition method.
	GetEditionFunc func(ID string, editionID string, state string) (*models.EditionUpdate, error)

	// GetEditionsFunc mocks the GetEditions method.
	GetEditionsFunc func(ctx context.Context, ID string, state string, offset int, limit int, authorised bool) ([]*models.EditionUpdate, int, error)

	// GetInstanceFunc mocks the GetInstance method.
	GetInstanceFunc func(ID string, eTagSelector string) (*models.Instance, error)

	// GetInstancesFunc mocks the GetInstances method.
	GetInstancesFunc func(ctx context.Context, states []string, datasets []string, offset int, limit int) ([]*models.Instance, int, error)

	// GetNextVersionFunc mocks the GetNextVersion method.
	GetNextVersionFunc func(datasetID string, editionID string) (int, error)

	// GetUniqueDimensionAndOptionsFunc mocks the GetUniqueDimensionAndOptions method.
	GetUniqueDimensionAndOptionsFunc func(ctx context.Context, ID string, dimension string, offset int, limit int) ([]*string, int, error)

	// GetVersionFunc mocks the GetVersion method.
	GetVersionFunc func(datasetID string, editionID string, version int, state string) (*models.Version, error)

	// GetVersionsFunc mocks the GetVersions method.
	GetVersionsFunc func(ctx context.Context, datasetID string, editionID string, state string, offset int, limit int) ([]models.Version, int, error)

	// UnlockInstanceFunc mocks the UnlockInstance method.
	UnlockInstanceFunc func(lockID string) error

	// UpdateBuildHierarchyTaskStateFunc mocks the UpdateBuildHierarchyTaskState method.
	UpdateBuildHierarchyTaskStateFunc func(currentInstance *models.Instance, dimension string, state string, eTagSelector string) (string, error)

	// UpdateBuildSearchTaskStateFunc mocks the UpdateBuildSearchTaskState method.
	UpdateBuildSearchTaskStateFunc func(currentInstance *models.Instance, dimension string, state string, eTagSelector string) (string, error)

	// UpdateDatasetFunc mocks the UpdateDataset method.
	UpdateDatasetFunc func(ctx context.Context, ID string, dataset *models.Dataset, currentState string) error

	// UpdateDatasetWithAssociationFunc mocks the UpdateDatasetWithAssociation method.
	UpdateDatasetWithAssociationFunc func(ID string, state string, version *models.Version) error

	// UpdateDimensionNodeIDAndOrderFunc mocks the UpdateDimensionNodeIDAndOrder method.
	UpdateDimensionNodeIDAndOrderFunc func(dimension *models.DimensionOption) error

	// UpdateETagForNodeIDAndOrderFunc mocks the UpdateETagForNodeIDAndOrder method.
	UpdateETagForNodeIDAndOrderFunc func(currentInstance *models.Instance, nodeID string, order *int, eTagSelector string) (string, error)

	// UpdateETagForOptionsFunc mocks the UpdateETagForOptions method.
	UpdateETagForOptionsFunc func(currentInstance *models.Instance, option *models.CachedDimensionOption, eTagSelector string) (string, error)

	// UpdateImportObservationsTaskStateFunc mocks the UpdateImportObservationsTaskState method.
	UpdateImportObservationsTaskStateFunc func(currentInstance *models.Instance, state string, eTagSelector string) (string, error)

	// UpdateInstanceFunc mocks the UpdateInstance method.
	UpdateInstanceFunc func(ctx context.Context, currentInstance *models.Instance, updatedInstance *models.Instance, eTagSelector string) (string, error)

	// UpdateObservationInsertedFunc mocks the UpdateObservationInserted method.
	UpdateObservationInsertedFunc func(currentInstance *models.Instance, observationInserted int64, eTagSelector string) (string, error)

	// UpdateVersionFunc mocks the UpdateVersion method.
	UpdateVersionFunc func(ID string, version *models.Version) error

	// UpsertContactFunc mocks the UpsertContact method.
	UpsertContactFunc func(ID string, update interface{}) error

	// UpsertDatasetFunc mocks the UpsertDataset method.
	UpsertDatasetFunc func(ID string, datasetDoc *models.DatasetUpdate) error

	// UpsertEditionFunc mocks the UpsertEdition method.
	UpsertEditionFunc func(datasetID string, edition string, editionDoc *models.EditionUpdate) error

	// UpsertVersionFunc mocks the UpsertVersion method.
	UpsertVersionFunc func(ID string, versionDoc *models.Version) error

	// calls tracks calls to the methods.
	calls struct {
		// AcquireInstanceLock holds details about calls to the AcquireInstanceLock method.
		AcquireInstanceLock []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// InstanceID is the instanceID argument value.
			InstanceID string
		}
		// AddDimensionToInstance holds details about calls to the AddDimensionToInstance method.
		AddDimensionToInstance []struct {
			// Dimension is the dimension argument value.
			Dimension *models.CachedDimensionOption
		}
		// AddEventToInstance holds details about calls to the AddEventToInstance method.
		AddEventToInstance []struct {
			// CurrentInstance is the currentInstance argument value.
			CurrentInstance *models.Instance
			// Event is the event argument value.
			Event *models.Event
			// ETagSelector is the eTagSelector argument value.
			ETagSelector string
		}
		// AddInstance holds details about calls to the AddInstance method.
		AddInstance []struct {
			// Instance is the instance argument value.
			Instance *models.Instance
		}
		// CheckDatasetExists holds details about calls to the CheckDatasetExists method.
		CheckDatasetExists []struct {
			// ID is the ID argument value.
			ID string
			// State is the state argument value.
			State string
		}
		// CheckEditionExists holds details about calls to the CheckEditionExists method.
		CheckEditionExists []struct {
			// ID is the ID argument value.
			ID string
			// EditionID is the editionID argument value.
			EditionID string
			// State is the state argument value.
			State string
		}
		// Checker holds details about calls to the Checker method.
		Checker []struct {
			// In1 is the in1 argument value.
			In1 context.Context
			// In2 is the in2 argument value.
			In2 *healthcheck.CheckState
		}
		// Close holds details about calls to the Close method.
		Close []struct {
			// In1 is the in1 argument value.
			In1 context.Context
		}
		// DeleteDataset holds details about calls to the DeleteDataset method.
		DeleteDataset []struct {
			// ID is the ID argument value.
			ID string
		}
		// DeleteEdition holds details about calls to the DeleteEdition method.
		DeleteEdition []struct {
			// ID is the ID argument value.
			ID string
		}
		// GetDataset holds details about calls to the GetDataset method.
		GetDataset []struct {
			// ID is the ID argument value.
			ID string
		}
		// GetDatasets holds details about calls to the GetDatasets method.
		GetDatasets []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Offset is the offset argument value.
			Offset int
			// Limit is the limit argument value.
			Limit int
			// Authorised is the authorised argument value.
			Authorised bool
		}
		// GetDimensionOptions holds details about calls to the GetDimensionOptions method.
		GetDimensionOptions []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Version is the version argument value.
			Version *models.Version
			// Dimension is the dimension argument value.
			Dimension string
			// Offset is the offset argument value.
			Offset int
			// Limit is the limit argument value.
			Limit int
		}
		// GetDimensionOptionsFromIDs holds details about calls to the GetDimensionOptionsFromIDs method.
		GetDimensionOptionsFromIDs []struct {
			// Version is the version argument value.
			Version *models.Version
			// Dimension is the dimension argument value.
			Dimension string
			// Ids is the ids argument value.
			Ids []string
		}
		// GetDimensions holds details about calls to the GetDimensions method.
		GetDimensions []struct {
			// DatasetID is the datasetID argument value.
			DatasetID string
			// VersionID is the versionID argument value.
			VersionID string
		}
		// GetDimensionsFromInstance holds details about calls to the GetDimensionsFromInstance method.
		GetDimensionsFromInstance []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the ID argument value.
			ID string
			// Offset is the offset argument value.
			Offset int
			// Limit is the limit argument value.
			Limit int
		}
		// GetEdition holds details about calls to the GetEdition method.
		GetEdition []struct {
			// ID is the ID argument value.
			ID string
			// EditionID is the editionID argument value.
			EditionID string
			// State is the state argument value.
			State string
		}
		// GetEditions holds details about calls to the GetEditions method.
		GetEditions []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the ID argument value.
			ID string
			// State is the state argument value.
			State string
			// Offset is the offset argument value.
			Offset int
			// Limit is the limit argument value.
			Limit int
			// Authorised is the authorised argument value.
			Authorised bool
		}
		// GetInstance holds details about calls to the GetInstance method.
		GetInstance []struct {
			// ID is the ID argument value.
			ID string
			// ETagSelector is the eTagSelector argument value.
			ETagSelector string
		}
		// GetInstances holds details about calls to the GetInstances method.
		GetInstances []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// States is the states argument value.
			States []string
			// Datasets is the datasets argument value.
			Datasets []string
			// Offset is the offset argument value.
			Offset int
			// Limit is the limit argument value.
			Limit int
		}
		// GetNextVersion holds details about calls to the GetNextVersion method.
		GetNextVersion []struct {
			// DatasetID is the datasetID argument value.
			DatasetID string
			// EditionID is the editionID argument value.
			EditionID string
		}
		// GetUniqueDimensionAndOptions holds details about calls to the GetUniqueDimensionAndOptions method.
		GetUniqueDimensionAndOptions []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the ID argument value.
			ID string
			// Dimension is the dimension argument value.
			Dimension string
			// Offset is the offset argument value.
			Offset int
			// Limit is the limit argument value.
			Limit int
		}
		// GetVersion holds details about calls to the GetVersion method.
		GetVersion []struct {
			// DatasetID is the datasetID argument value.
			DatasetID string
			// EditionID is the editionID argument value.
			EditionID string
			// Version is the version argument value.
			Version int
			// State is the state argument value.
			State string
		}
		// GetVersions holds details about calls to the GetVersions method.
		GetVersions []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// DatasetID is the datasetID argument value.
			DatasetID string
			// EditionID is the editionID argument value.
			EditionID string
			// State is the state argument value.
			State string
			// Offset is the offset argument value.
			Offset int
			// Limit is the limit argument value.
			Limit int
		}
		// UnlockInstance holds details about calls to the UnlockInstance method.
		UnlockInstance []struct {
			// LockID is the lockID argument value.
			LockID string
		}
		// UpdateBuildHierarchyTaskState holds details about calls to the UpdateBuildHierarchyTaskState method.
		UpdateBuildHierarchyTaskState []struct {
			// CurrentInstance is the currentInstance argument value.
			CurrentInstance *models.Instance
			// Dimension is the dimension argument value.
			Dimension string
			// State is the state argument value.
			State string
			// ETagSelector is the eTagSelector argument value.
			ETagSelector string
		}
		// UpdateBuildSearchTaskState holds details about calls to the UpdateBuildSearchTaskState method.
		UpdateBuildSearchTaskState []struct {
			// CurrentInstance is the currentInstance argument value.
			CurrentInstance *models.Instance
			// Dimension is the dimension argument value.
			Dimension string
			// State is the state argument value.
			State string
			// ETagSelector is the eTagSelector argument value.
			ETagSelector string
		}
		// UpdateDataset holds details about calls to the UpdateDataset method.
		UpdateDataset []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the ID argument value.
			ID string
			// Dataset is the dataset argument value.
			Dataset *models.Dataset
			// CurrentState is the currentState argument value.
			CurrentState string
		}
		// UpdateDatasetWithAssociation holds details about calls to the UpdateDatasetWithAssociation method.
		UpdateDatasetWithAssociation []struct {
			// ID is the ID argument value.
			ID string
			// State is the state argument value.
			State string
			// Version is the version argument value.
			Version *models.Version
		}
		// UpdateDimensionNodeIDAndOrder holds details about calls to the UpdateDimensionNodeIDAndOrder method.
		UpdateDimensionNodeIDAndOrder []struct {
			// Dimension is the dimension argument value.
			Dimension *models.DimensionOption
		}
		// UpdateETagForNodeIDAndOrder holds details about calls to the UpdateETagForNodeIDAndOrder method.
		UpdateETagForNodeIDAndOrder []struct {
			// CurrentInstance is the currentInstance argument value.
			CurrentInstance *models.Instance
			// NodeID is the nodeID argument value.
			NodeID string
			// Order is the order argument value.
			Order *int
			// ETagSelector is the eTagSelector argument value.
			ETagSelector string
		}
		// UpdateETagForOptions holds details about calls to the UpdateETagForOptions method.
		UpdateETagForOptions []struct {
			// CurrentInstance is the currentInstance argument value.
			CurrentInstance *models.Instance
			// Option is the option argument value.
			Option *models.CachedDimensionOption
			// ETagSelector is the eTagSelector argument value.
			ETagSelector string
		}
		// UpdateImportObservationsTaskState holds details about calls to the UpdateImportObservationsTaskState method.
		UpdateImportObservationsTaskState []struct {
			// CurrentInstance is the currentInstance argument value.
			CurrentInstance *models.Instance
			// State is the state argument value.
			State string
			// ETagSelector is the eTagSelector argument value.
			ETagSelector string
		}
		// UpdateInstance holds details about calls to the UpdateInstance method.
		UpdateInstance []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// CurrentInstance is the currentInstance argument value.
			CurrentInstance *models.Instance
			// UpdatedInstance is the updatedInstance argument value.
			UpdatedInstance *models.Instance
			// ETagSelector is the eTagSelector argument value.
			ETagSelector string
		}
		// UpdateObservationInserted holds details about calls to the UpdateObservationInserted method.
		UpdateObservationInserted []struct {
			// CurrentInstance is the currentInstance argument value.
			CurrentInstance *models.Instance
			// ObservationInserted is the observationInserted argument value.
			ObservationInserted int64
			// ETagSelector is the eTagSelector argument value.
			ETagSelector string
		}
		// UpdateVersion holds details about calls to the UpdateVersion method.
		UpdateVersion []struct {
			// ID is the ID argument value.
			ID string
			// Version is the version argument value.
			Version *models.Version
		}
		// UpsertContact holds details about calls to the UpsertContact method.
		UpsertContact []struct {
			// ID is the ID argument value.
			ID string
			// Update is the update argument value.
			Update interface{}
		}
		// UpsertDataset holds details about calls to the UpsertDataset method.
		UpsertDataset []struct {
			// ID is the ID argument value.
			ID string
			// DatasetDoc is the datasetDoc argument value.
			DatasetDoc *models.DatasetUpdate
		}
		// UpsertEdition holds details about calls to the UpsertEdition method.
		UpsertEdition []struct {
			// DatasetID is the datasetID argument value.
			DatasetID string
			// Edition is the edition argument value.
			Edition string
			// EditionDoc is the editionDoc argument value.
			EditionDoc *models.EditionUpdate
		}
		// UpsertVersion holds details about calls to the UpsertVersion method.
		UpsertVersion []struct {
			// ID is the ID argument value.
			ID string
			// VersionDoc is the versionDoc argument value.
			VersionDoc *models.Version
		}
	}
}

// AcquireInstanceLock calls AcquireInstanceLockFunc.
func (mock *MongoDBMock) AcquireInstanceLock(ctx context.Context, instanceID string) (string, error) {
	if mock.AcquireInstanceLockFunc == nil {
		panic("MongoDBMock.AcquireInstanceLockFunc: method is nil but MongoDB.AcquireInstanceLock was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		InstanceID string
	}{
		Ctx:        ctx,
		InstanceID: instanceID,
	}
	lockMongoDBMockAcquireInstanceLock.Lock()
	mock.calls.AcquireInstanceLock = append(mock.calls.AcquireInstanceLock, callInfo)
	lockMongoDBMockAcquireInstanceLock.Unlock()
	return mock.AcquireInstanceLockFunc(ctx, instanceID)
}

// AcquireInstanceLockCalls gets all the calls that were made to AcquireInstanceLock.
// Check the length with:
//     len(mockedMongoDB.AcquireInstanceLockCalls())
func (mock *MongoDBMock) AcquireInstanceLockCalls() []struct {
	Ctx        context.Context
	InstanceID string
} {
	var calls []struct {
		Ctx        context.Context
		InstanceID string
	}
	lockMongoDBMockAcquireInstanceLock.RLock()
	calls = mock.calls.AcquireInstanceLock
	lockMongoDBMockAcquireInstanceLock.RUnlock()
	return calls
}

// AddDimensionToInstance calls AddDimensionToInstanceFunc.
func (mock *MongoDBMock) AddDimensionToInstance(dimension *models.CachedDimensionOption) error {
	if mock.AddDimensionToInstanceFunc == nil {
		panic("MongoDBMock.AddDimensionToInstanceFunc: method is nil but MongoDB.AddDimensionToInstance was just called")
	}
	callInfo := struct {
		Dimension *models.CachedDimensionOption
	}{
		Dimension: dimension,
	}
	lockMongoDBMockAddDimensionToInstance.Lock()
	mock.calls.AddDimensionToInstance = append(mock.calls.AddDimensionToInstance, callInfo)
	lockMongoDBMockAddDimensionToInstance.Unlock()
	return mock.AddDimensionToInstanceFunc(dimension)
}

// AddDimensionToInstanceCalls gets all the calls that were made to AddDimensionToInstance.
// Check the length with:
//     len(mockedMongoDB.AddDimensionToInstanceCalls())
func (mock *MongoDBMock) AddDimensionToInstanceCalls() []struct {
	Dimension *models.CachedDimensionOption
} {
	var calls []struct {
		Dimension *models.CachedDimensionOption
	}
	lockMongoDBMockAddDimensionToInstance.RLock()
	calls = mock.calls.AddDimensionToInstance
	lockMongoDBMockAddDimensionToInstance.RUnlock()
	return calls
}

// AddEventToInstance calls AddEventToInstanceFunc.
func (mock *MongoDBMock) AddEventToInstance(currentInstance *models.Instance, event *models.Event, eTagSelector string) (string, error) {
	if mock.AddEventToInstanceFunc == nil {
		panic("MongoDBMock.AddEventToInstanceFunc: method is nil but MongoDB.AddEventToInstance was just called")
	}
	callInfo := struct {
		CurrentInstance *models.Instance
		Event           *models.Event
		ETagSelector    string
	}{
		CurrentInstance: currentInstance,
		Event:           event,
		ETagSelector:    eTagSelector,
	}
	lockMongoDBMockAddEventToInstance.Lock()
	mock.calls.AddEventToInstance = append(mock.calls.AddEventToInstance, callInfo)
	lockMongoDBMockAddEventToInstance.Unlock()
	return mock.AddEventToInstanceFunc(currentInstance, event, eTagSelector)
}

// AddEventToInstanceCalls gets all the calls that were made to AddEventToInstance.
// Check the length with:
//     len(mockedMongoDB.AddEventToInstanceCalls())
func (mock *MongoDBMock) AddEventToInstanceCalls() []struct {
	CurrentInstance *models.Instance
	Event           *models.Event
	ETagSelector    string
} {
	var calls []struct {
		CurrentInstance *models.Instance
		Event           *models.Event
		ETagSelector    string
	}
	lockMongoDBMockAddEventToInstance.RLock()
	calls = mock.calls.AddEventToInstance
	lockMongoDBMockAddEventToInstance.RUnlock()
	return calls
}

// AddInstance calls AddInstanceFunc.
func (mock *MongoDBMock) AddInstance(instance *models.Instance) (*models.Instance, error) {
	if mock.AddInstanceFunc == nil {
		panic("MongoDBMock.AddInstanceFunc: method is nil but MongoDB.AddInstance was just called")
	}
	callInfo := struct {
		Instance *models.Instance
	}{
		Instance: instance,
	}
	lockMongoDBMockAddInstance.Lock()
	mock.calls.AddInstance = append(mock.calls.AddInstance, callInfo)
	lockMongoDBMockAddInstance.Unlock()
	return mock.AddInstanceFunc(instance)
}

// AddInstanceCalls gets all the calls that were made to AddInstance.
// Check the length with:
//     len(mockedMongoDB.AddInstanceCalls())
func (mock *MongoDBMock) AddInstanceCalls() []struct {
	Instance *models.Instance
} {
	var calls []struct {
		Instance *models.Instance
	}
	lockMongoDBMockAddInstance.RLock()
	calls = mock.calls.AddInstance
	lockMongoDBMockAddInstance.RUnlock()
	return calls
}

// CheckDatasetExists calls CheckDatasetExistsFunc.
func (mock *MongoDBMock) CheckDatasetExists(ID string, state string) error {
	if mock.CheckDatasetExistsFunc == nil {
		panic("MongoDBMock.CheckDatasetExistsFunc: method is nil but MongoDB.CheckDatasetExists was just called")
	}
	callInfo := struct {
		ID    string
		State string
	}{
		ID:    ID,
		State: state,
	}
	lockMongoDBMockCheckDatasetExists.Lock()
	mock.calls.CheckDatasetExists = append(mock.calls.CheckDatasetExists, callInfo)
	lockMongoDBMockCheckDatasetExists.Unlock()
	return mock.CheckDatasetExistsFunc(ID, state)
}

// CheckDatasetExistsCalls gets all the calls that were made to CheckDatasetExists.
// Check the length with:
//     len(mockedMongoDB.CheckDatasetExistsCalls())
func (mock *MongoDBMock) CheckDatasetExistsCalls() []struct {
	ID    string
	State string
} {
	var calls []struct {
		ID    string
		State string
	}
	lockMongoDBMockCheckDatasetExists.RLock()
	calls = mock.calls.CheckDatasetExists
	lockMongoDBMockCheckDatasetExists.RUnlock()
	return calls
}

// CheckEditionExists calls CheckEditionExistsFunc.
func (mock *MongoDBMock) CheckEditionExists(ID string, editionID string, state string) error {
	if mock.CheckEditionExistsFunc == nil {
		panic("MongoDBMock.CheckEditionExistsFunc: method is nil but MongoDB.CheckEditionExists was just called")
	}
	callInfo := struct {
		ID        string
		EditionID string
		State     string
	}{
		ID:        ID,
		EditionID: editionID,
		State:     state,
	}
	lockMongoDBMockCheckEditionExists.Lock()
	mock.calls.CheckEditionExists = append(mock.calls.CheckEditionExists, callInfo)
	lockMongoDBMockCheckEditionExists.Unlock()
	return mock.CheckEditionExistsFunc(ID, editionID, state)
}

// CheckEditionExistsCalls gets all the calls that were made to CheckEditionExists.
// Check the length with:
//     len(mockedMongoDB.CheckEditionExistsCalls())
func (mock *MongoDBMock) CheckEditionExistsCalls() []struct {
	ID        string
	EditionID string
	State     string
} {
	var calls []struct {
		ID        string
		EditionID string
		State     string
	}
	lockMongoDBMockCheckEditionExists.RLock()
	calls = mock.calls.CheckEditionExists
	lockMongoDBMockCheckEditionExists.RUnlock()
	return calls
}

// Checker calls CheckerFunc.
func (mock *MongoDBMock) Checker(in1 context.Context, in2 *healthcheck.CheckState) error {
	if mock.CheckerFunc == nil {
		panic("MongoDBMock.CheckerFunc: method is nil but MongoDB.Checker was just called")
	}
	callInfo := struct {
		In1 context.Context
		In2 *healthcheck.CheckState
	}{
		In1: in1,
		In2: in2,
	}
	lockMongoDBMockChecker.Lock()
	mock.calls.Checker = append(mock.calls.Checker, callInfo)
	lockMongoDBMockChecker.Unlock()
	return mock.CheckerFunc(in1, in2)
}

// CheckerCalls gets all the calls that were made to Checker.
// Check the length with:
//     len(mockedMongoDB.CheckerCalls())
func (mock *MongoDBMock) CheckerCalls() []struct {
	In1 context.Context
	In2 *healthcheck.CheckState
} {
	var calls []struct {
		In1 context.Context
		In2 *healthcheck.CheckState
	}
	lockMongoDBMockChecker.RLock()
	calls = mock.calls.Checker
	lockMongoDBMockChecker.RUnlock()
	return calls
}

// Close calls CloseFunc.
func (mock *MongoDBMock) Close(in1 context.Context) error {
	if mock.CloseFunc == nil {
		panic("MongoDBMock.CloseFunc: method is nil but MongoDB.Close was just called")
	}
	callInfo := struct {
		In1 context.Context
	}{
		In1: in1,
	}
	lockMongoDBMockClose.Lock()
	mock.calls.Close = append(mock.calls.Close, callInfo)
	lockMongoDBMockClose.Unlock()
	return mock.CloseFunc(in1)
}

// CloseCalls gets all the calls that were made to Close.
// Check the length with:
//     len(mockedMongoDB.CloseCalls())
func (mock *MongoDBMock) CloseCalls() []struct {
	In1 context.Context
} {
	var calls []struct {
		In1 context.Context
	}
	lockMongoDBMockClose.RLock()
	calls = mock.calls.Close
	lockMongoDBMockClose.RUnlock()
	return calls
}

// DeleteDataset calls DeleteDatasetFunc.
func (mock *MongoDBMock) DeleteDataset(ID string) error {
	if mock.DeleteDatasetFunc == nil {
		panic("MongoDBMock.DeleteDatasetFunc: method is nil but MongoDB.DeleteDataset was just called")
	}
	callInfo := struct {
		ID string
	}{
		ID: ID,
	}
	lockMongoDBMockDeleteDataset.Lock()
	mock.calls.DeleteDataset = append(mock.calls.DeleteDataset, callInfo)
	lockMongoDBMockDeleteDataset.Unlock()
	return mock.DeleteDatasetFunc(ID)
}

// DeleteDatasetCalls gets all the calls that were made to DeleteDataset.
// Check the length with:
//     len(mockedMongoDB.DeleteDatasetCalls())
func (mock *MongoDBMock) DeleteDatasetCalls() []struct {
	ID string
} {
	var calls []struct {
		ID string
	}
	lockMongoDBMockDeleteDataset.RLock()
	calls = mock.calls.DeleteDataset
	lockMongoDBMockDeleteDataset.RUnlock()
	return calls
}

// DeleteEdition calls DeleteEditionFunc.
func (mock *MongoDBMock) DeleteEdition(ID string) error {
	if mock.DeleteEditionFunc == nil {
		panic("MongoDBMock.DeleteEditionFunc: method is nil but MongoDB.DeleteEdition was just called")
	}
	callInfo := struct {
		ID string
	}{
		ID: ID,
	}
	lockMongoDBMockDeleteEdition.Lock()
	mock.calls.DeleteEdition = append(mock.calls.DeleteEdition, callInfo)
	lockMongoDBMockDeleteEdition.Unlock()
	return mock.DeleteEditionFunc(ID)
}

// DeleteEditionCalls gets all the calls that were made to DeleteEdition.
// Check the length with:
//     len(mockedMongoDB.DeleteEditionCalls())
func (mock *MongoDBMock) DeleteEditionCalls() []struct {
	ID string
} {
	var calls []struct {
		ID string
	}
	lockMongoDBMockDeleteEdition.RLock()
	calls = mock.calls.DeleteEdition
	lockMongoDBMockDeleteEdition.RUnlock()
	return calls
}

// GetDataset calls GetDatasetFunc.
func (mock *MongoDBMock) GetDataset(ID string) (*models.DatasetUpdate, error) {
	if mock.GetDatasetFunc == nil {
		panic("MongoDBMock.GetDatasetFunc: method is nil but MongoDB.GetDataset was just called")
	}
	callInfo := struct {
		ID string
	}{
		ID: ID,
	}
	lockMongoDBMockGetDataset.Lock()
	mock.calls.GetDataset = append(mock.calls.GetDataset, callInfo)
	lockMongoDBMockGetDataset.Unlock()
	return mock.GetDatasetFunc(ID)
}

// GetDatasetCalls gets all the calls that were made to GetDataset.
// Check the length with:
//     len(mockedMongoDB.GetDatasetCalls())
func (mock *MongoDBMock) GetDatasetCalls() []struct {
	ID string
} {
	var calls []struct {
		ID string
	}
	lockMongoDBMockGetDataset.RLock()
	calls = mock.calls.GetDataset
	lockMongoDBMockGetDataset.RUnlock()
	return calls
}

// GetDatasets calls GetDatasetsFunc.
func (mock *MongoDBMock) GetDatasets(ctx context.Context, offset int, limit int, authorised bool) ([]*models.DatasetUpdate, int, error) {
	if mock.GetDatasetsFunc == nil {
		panic("MongoDBMock.GetDatasetsFunc: method is nil but MongoDB.GetDatasets was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		Offset     int
		Limit      int
		Authorised bool
	}{
		Ctx:        ctx,
		Offset:     offset,
		Limit:      limit,
		Authorised: authorised,
	}
	lockMongoDBMockGetDatasets.Lock()
	mock.calls.GetDatasets = append(mock.calls.GetDatasets, callInfo)
	lockMongoDBMockGetDatasets.Unlock()
	return mock.GetDatasetsFunc(ctx, offset, limit, authorised)
}

// GetDatasetsCalls gets all the calls that were made to GetDatasets.
// Check the length with:
//     len(mockedMongoDB.GetDatasetsCalls())
func (mock *MongoDBMock) GetDatasetsCalls() []struct {
	Ctx        context.Context
	Offset     int
	Limit      int
	Authorised bool
} {
	var calls []struct {
		Ctx        context.Context
		Offset     int
		Limit      int
		Authorised bool
	}
	lockMongoDBMockGetDatasets.RLock()
	calls = mock.calls.GetDatasets
	lockMongoDBMockGetDatasets.RUnlock()
	return calls
}

// GetDimensionOptions calls GetDimensionOptionsFunc.
func (mock *MongoDBMock) GetDimensionOptions(ctx context.Context, version *models.Version, dimension string, offset int, limit int) ([]*models.PublicDimensionOption, int, error) {
	if mock.GetDimensionOptionsFunc == nil {
		panic("MongoDBMock.GetDimensionOptionsFunc: method is nil but MongoDB.GetDimensionOptions was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		Version   *models.Version
		Dimension string
		Offset    int
		Limit     int
	}{
		Ctx:       ctx,
		Version:   version,
		Dimension: dimension,
		Offset:    offset,
		Limit:     limit,
	}
	lockMongoDBMockGetDimensionOptions.Lock()
	mock.calls.GetDimensionOptions = append(mock.calls.GetDimensionOptions, callInfo)
	lockMongoDBMockGetDimensionOptions.Unlock()
	return mock.GetDimensionOptionsFunc(ctx, version, dimension, offset, limit)
}

// GetDimensionOptionsCalls gets all the calls that were made to GetDimensionOptions.
// Check the length with:
//     len(mockedMongoDB.GetDimensionOptionsCalls())
func (mock *MongoDBMock) GetDimensionOptionsCalls() []struct {
	Ctx       context.Context
	Version   *models.Version
	Dimension string
	Offset    int
	Limit     int
} {
	var calls []struct {
		Ctx       context.Context
		Version   *models.Version
		Dimension string
		Offset    int
		Limit     int
	}
	lockMongoDBMockGetDimensionOptions.RLock()
	calls = mock.calls.GetDimensionOptions
	lockMongoDBMockGetDimensionOptions.RUnlock()
	return calls
}

// GetDimensionOptionsFromIDs calls GetDimensionOptionsFromIDsFunc.
func (mock *MongoDBMock) GetDimensionOptionsFromIDs(version *models.Version, dimension string, ids []string) ([]*models.PublicDimensionOption, int, error) {
	if mock.GetDimensionOptionsFromIDsFunc == nil {
		panic("MongoDBMock.GetDimensionOptionsFromIDsFunc: method is nil but MongoDB.GetDimensionOptionsFromIDs was just called")
	}
	callInfo := struct {
		Version   *models.Version
		Dimension string
		Ids       []string
	}{
		Version:   version,
		Dimension: dimension,
		Ids:       ids,
	}
	lockMongoDBMockGetDimensionOptionsFromIDs.Lock()
	mock.calls.GetDimensionOptionsFromIDs = append(mock.calls.GetDimensionOptionsFromIDs, callInfo)
	lockMongoDBMockGetDimensionOptionsFromIDs.Unlock()
	return mock.GetDimensionOptionsFromIDsFunc(version, dimension, ids)
}

// GetDimensionOptionsFromIDsCalls gets all the calls that were made to GetDimensionOptionsFromIDs.
// Check the length with:
//     len(mockedMongoDB.GetDimensionOptionsFromIDsCalls())
func (mock *MongoDBMock) GetDimensionOptionsFromIDsCalls() []struct {
	Version   *models.Version
	Dimension string
	Ids       []string
} {
	var calls []struct {
		Version   *models.Version
		Dimension string
		Ids       []string
	}
	lockMongoDBMockGetDimensionOptionsFromIDs.RLock()
	calls = mock.calls.GetDimensionOptionsFromIDs
	lockMongoDBMockGetDimensionOptionsFromIDs.RUnlock()
	return calls
}

// GetDimensions calls GetDimensionsFunc.
func (mock *MongoDBMock) GetDimensions(datasetID string, versionID string) ([]bson.M, error) {
	if mock.GetDimensionsFunc == nil {
		panic("MongoDBMock.GetDimensionsFunc: method is nil but MongoDB.GetDimensions was just called")
	}
	callInfo := struct {
		DatasetID string
		VersionID string
	}{
		DatasetID: datasetID,
		VersionID: versionID,
	}
	lockMongoDBMockGetDimensions.Lock()
	mock.calls.GetDimensions = append(mock.calls.GetDimensions, callInfo)
	lockMongoDBMockGetDimensions.Unlock()
	return mock.GetDimensionsFunc(datasetID, versionID)
}

// GetDimensionsCalls gets all the calls that were made to GetDimensions.
// Check the length with:
//     len(mockedMongoDB.GetDimensionsCalls())
func (mock *MongoDBMock) GetDimensionsCalls() []struct {
	DatasetID string
	VersionID string
} {
	var calls []struct {
		DatasetID string
		VersionID string
	}
	lockMongoDBMockGetDimensions.RLock()
	calls = mock.calls.GetDimensions
	lockMongoDBMockGetDimensions.RUnlock()
	return calls
}

// GetDimensionsFromInstance calls GetDimensionsFromInstanceFunc.
func (mock *MongoDBMock) GetDimensionsFromInstance(ctx context.Context, ID string, offset int, limit int) ([]*models.DimensionOption, int, error) {
	if mock.GetDimensionsFromInstanceFunc == nil {
		panic("MongoDBMock.GetDimensionsFromInstanceFunc: method is nil but MongoDB.GetDimensionsFromInstance was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		ID     string
		Offset int
		Limit  int
	}{
		Ctx:    ctx,
		ID:     ID,
		Offset: offset,
		Limit:  limit,
	}
	lockMongoDBMockGetDimensionsFromInstance.Lock()
	mock.calls.GetDimensionsFromInstance = append(mock.calls.GetDimensionsFromInstance, callInfo)
	lockMongoDBMockGetDimensionsFromInstance.Unlock()
	return mock.GetDimensionsFromInstanceFunc(ctx, ID, offset, limit)
}

// GetDimensionsFromInstanceCalls gets all the calls that were made to GetDimensionsFromInstance.
// Check the length with:
//     len(mockedMongoDB.GetDimensionsFromInstanceCalls())
func (mock *MongoDBMock) GetDimensionsFromInstanceCalls() []struct {
	Ctx    context.Context
	ID     string
	Offset int
	Limit  int
} {
	var calls []struct {
		Ctx    context.Context
		ID     string
		Offset int
		Limit  int
	}
	lockMongoDBMockGetDimensionsFromInstance.RLock()
	calls = mock.calls.GetDimensionsFromInstance
	lockMongoDBMockGetDimensionsFromInstance.RUnlock()
	return calls
}

// GetEdition calls GetEditionFunc.
func (mock *MongoDBMock) GetEdition(ID string, editionID string, state string) (*models.EditionUpdate, error) {
	if mock.GetEditionFunc == nil {
		panic("MongoDBMock.GetEditionFunc: method is nil but MongoDB.GetEdition was just called")
	}
	callInfo := struct {
		ID        string
		EditionID string
		State     string
	}{
		ID:        ID,
		EditionID: editionID,
		State:     state,
	}
	lockMongoDBMockGetEdition.Lock()
	mock.calls.GetEdition = append(mock.calls.GetEdition, callInfo)
	lockMongoDBMockGetEdition.Unlock()
	return mock.GetEditionFunc(ID, editionID, state)
}

// GetEditionCalls gets all the calls that were made to GetEdition.
// Check the length with:
//     len(mockedMongoDB.GetEditionCalls())
func (mock *MongoDBMock) GetEditionCalls() []struct {
	ID        string
	EditionID string
	State     string
} {
	var calls []struct {
		ID        string
		EditionID string
		State     string
	}
	lockMongoDBMockGetEdition.RLock()
	calls = mock.calls.GetEdition
	lockMongoDBMockGetEdition.RUnlock()
	return calls
}

// GetEditions calls GetEditionsFunc.
func (mock *MongoDBMock) GetEditions(ctx context.Context, ID string, state string, offset int, limit int, authorised bool) ([]*models.EditionUpdate, int, error) {
	if mock.GetEditionsFunc == nil {
		panic("MongoDBMock.GetEditionsFunc: method is nil but MongoDB.GetEditions was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		ID         string
		State      string
		Offset     int
		Limit      int
		Authorised bool
	}{
		Ctx:        ctx,
		ID:         ID,
		State:      state,
		Offset:     offset,
		Limit:      limit,
		Authorised: authorised,
	}
	lockMongoDBMockGetEditions.Lock()
	mock.calls.GetEditions = append(mock.calls.GetEditions, callInfo)
	lockMongoDBMockGetEditions.Unlock()
	return mock.GetEditionsFunc(ctx, ID, state, offset, limit, authorised)
}

// GetEditionsCalls gets all the calls that were made to GetEditions.
// Check the length with:
//     len(mockedMongoDB.GetEditionsCalls())
func (mock *MongoDBMock) GetEditionsCalls() []struct {
	Ctx        context.Context
	ID         string
	State      string
	Offset     int
	Limit      int
	Authorised bool
} {
	var calls []struct {
		Ctx        context.Context
		ID         string
		State      string
		Offset     int
		Limit      int
		Authorised bool
	}
	lockMongoDBMockGetEditions.RLock()
	calls = mock.calls.GetEditions
	lockMongoDBMockGetEditions.RUnlock()
	return calls
}

// GetInstance calls GetInstanceFunc.
func (mock *MongoDBMock) GetInstance(ID string, eTagSelector string) (*models.Instance, error) {
	if mock.GetInstanceFunc == nil {
		panic("MongoDBMock.GetInstanceFunc: method is nil but MongoDB.GetInstance was just called")
	}
	callInfo := struct {
		ID           string
		ETagSelector string
	}{
		ID:           ID,
		ETagSelector: eTagSelector,
	}
	lockMongoDBMockGetInstance.Lock()
	mock.calls.GetInstance = append(mock.calls.GetInstance, callInfo)
	lockMongoDBMockGetInstance.Unlock()
	return mock.GetInstanceFunc(ID, eTagSelector)
}

// GetInstanceCalls gets all the calls that were made to GetInstance.
// Check the length with:
//     len(mockedMongoDB.GetInstanceCalls())
func (mock *MongoDBMock) GetInstanceCalls() []struct {
	ID           string
	ETagSelector string
} {
	var calls []struct {
		ID           string
		ETagSelector string
	}
	lockMongoDBMockGetInstance.RLock()
	calls = mock.calls.GetInstance
	lockMongoDBMockGetInstance.RUnlock()
	return calls
}

// GetInstances calls GetInstancesFunc.
func (mock *MongoDBMock) GetInstances(ctx context.Context, states []string, datasets []string, offset int, limit int) ([]*models.Instance, int, error) {
	if mock.GetInstancesFunc == nil {
		panic("MongoDBMock.GetInstancesFunc: method is nil but MongoDB.GetInstances was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		States   []string
		Datasets []string
		Offset   int
		Limit    int
	}{
		Ctx:      ctx,
		States:   states,
		Datasets: datasets,
		Offset:   offset,
		Limit:    limit,
	}
	lockMongoDBMockGetInstances.Lock()
	mock.calls.GetInstances = append(mock.calls.GetInstances, callInfo)
	lockMongoDBMockGetInstances.Unlock()
	return mock.GetInstancesFunc(ctx, states, datasets, offset, limit)
}

// GetInstancesCalls gets all the calls that were made to GetInstances.
// Check the length with:
//     len(mockedMongoDB.GetInstancesCalls())
func (mock *MongoDBMock) GetInstancesCalls() []struct {
	Ctx      context.Context
	States   []string
	Datasets []string
	Offset   int
	Limit    int
} {
	var calls []struct {
		Ctx      context.Context
		States   []string
		Datasets []string
		Offset   int
		Limit    int
	}
	lockMongoDBMockGetInstances.RLock()
	calls = mock.calls.GetInstances
	lockMongoDBMockGetInstances.RUnlock()
	return calls
}

// GetNextVersion calls GetNextVersionFunc.
func (mock *MongoDBMock) GetNextVersion(datasetID string, editionID string) (int, error) {
	if mock.GetNextVersionFunc == nil {
		panic("MongoDBMock.GetNextVersionFunc: method is nil but MongoDB.GetNextVersion was just called")
	}
	callInfo := struct {
		DatasetID string
		EditionID string
	}{
		DatasetID: datasetID,
		EditionID: editionID,
	}
	lockMongoDBMockGetNextVersion.Lock()
	mock.calls.GetNextVersion = append(mock.calls.GetNextVersion, callInfo)
	lockMongoDBMockGetNextVersion.Unlock()
	return mock.GetNextVersionFunc(datasetID, editionID)
}

// GetNextVersionCalls gets all the calls that were made to GetNextVersion.
// Check the length with:
//     len(mockedMongoDB.GetNextVersionCalls())
func (mock *MongoDBMock) GetNextVersionCalls() []struct {
	DatasetID string
	EditionID string
} {
	var calls []struct {
		DatasetID string
		EditionID string
	}
	lockMongoDBMockGetNextVersion.RLock()
	calls = mock.calls.GetNextVersion
	lockMongoDBMockGetNextVersion.RUnlock()
	return calls
}

// GetUniqueDimensionAndOptions calls GetUniqueDimensionAndOptionsFunc.
func (mock *MongoDBMock) GetUniqueDimensionAndOptions(ctx context.Context, ID string, dimension string, offset int, limit int) ([]*string, int, error) {
	if mock.GetUniqueDimensionAndOptionsFunc == nil {
		panic("MongoDBMock.GetUniqueDimensionAndOptionsFunc: method is nil but MongoDB.GetUniqueDimensionAndOptions was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		ID        string
		Dimension string
		Offset    int
		Limit     int
	}{
		Ctx:       ctx,
		ID:        ID,
		Dimension: dimension,
		Offset:    offset,
		Limit:     limit,
	}
	lockMongoDBMockGetUniqueDimensionAndOptions.Lock()
	mock.calls.GetUniqueDimensionAndOptions = append(mock.calls.GetUniqueDimensionAndOptions, callInfo)
	lockMongoDBMockGetUniqueDimensionAndOptions.Unlock()
	return mock.GetUniqueDimensionAndOptionsFunc(ctx, ID, dimension, offset, limit)
}

// GetUniqueDimensionAndOptionsCalls gets all the calls that were made to GetUniqueDimensionAndOptions.
// Check the length with:
//     len(mockedMongoDB.GetUniqueDimensionAndOptionsCalls())
func (mock *MongoDBMock) GetUniqueDimensionAndOptionsCalls() []struct {
	Ctx       context.Context
	ID        string
	Dimension string
	Offset    int
	Limit     int
} {
	var calls []struct {
		Ctx       context.Context
		ID        string
		Dimension string
		Offset    int
		Limit     int
	}
	lockMongoDBMockGetUniqueDimensionAndOptions.RLock()
	calls = mock.calls.GetUniqueDimensionAndOptions
	lockMongoDBMockGetUniqueDimensionAndOptions.RUnlock()
	return calls
}

// GetVersion calls GetVersionFunc.
func (mock *MongoDBMock) GetVersion(datasetID string, editionID string, version int, state string) (*models.Version, error) {
	if mock.GetVersionFunc == nil {
		panic("MongoDBMock.GetVersionFunc: method is nil but MongoDB.GetVersion was just called")
	}
	callInfo := struct {
		DatasetID string
		EditionID string
		Version   int
		State     string
	}{
		DatasetID: datasetID,
		EditionID: editionID,
		Version:   version,
		State:     state,
	}
	lockMongoDBMockGetVersion.Lock()
	mock.calls.GetVersion = append(mock.calls.GetVersion, callInfo)
	lockMongoDBMockGetVersion.Unlock()
	return mock.GetVersionFunc(datasetID, editionID, version, state)
}

// GetVersionCalls gets all the calls that were made to GetVersion.
// Check the length with:
//     len(mockedMongoDB.GetVersionCalls())
func (mock *MongoDBMock) GetVersionCalls() []struct {
	DatasetID string
	EditionID string
	Version   int
	State     string
} {
	var calls []struct {
		DatasetID string
		EditionID string
		Version   int
		State     string
	}
	lockMongoDBMockGetVersion.RLock()
	calls = mock.calls.GetVersion
	lockMongoDBMockGetVersion.RUnlock()
	return calls
}

// GetVersions calls GetVersionsFunc.
func (mock *MongoDBMock) GetVersions(ctx context.Context, datasetID string, editionID string, state string, offset int, limit int) ([]models.Version, int, error) {
	if mock.GetVersionsFunc == nil {
		panic("MongoDBMock.GetVersionsFunc: method is nil but MongoDB.GetVersions was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		DatasetID string
		EditionID string
		State     string
		Offset    int
		Limit     int
	}{
		Ctx:       ctx,
		DatasetID: datasetID,
		EditionID: editionID,
		State:     state,
		Offset:    offset,
		Limit:     limit,
	}
	lockMongoDBMockGetVersions.Lock()
	mock.calls.GetVersions = append(mock.calls.GetVersions, callInfo)
	lockMongoDBMockGetVersions.Unlock()
	return mock.GetVersionsFunc(ctx, datasetID, editionID, state, offset, limit)
}

// GetVersionsCalls gets all the calls that were made to GetVersions.
// Check the length with:
//     len(mockedMongoDB.GetVersionsCalls())
func (mock *MongoDBMock) GetVersionsCalls() []struct {
	Ctx       context.Context
	DatasetID string
	EditionID string
	State     string
	Offset    int
	Limit     int
} {
	var calls []struct {
		Ctx       context.Context
		DatasetID string
		EditionID string
		State     string
		Offset    int
		Limit     int
	}
	lockMongoDBMockGetVersions.RLock()
	calls = mock.calls.GetVersions
	lockMongoDBMockGetVersions.RUnlock()
	return calls
}

// UnlockInstance calls UnlockInstanceFunc.
func (mock *MongoDBMock) UnlockInstance(lockID string) error {
	if mock.UnlockInstanceFunc == nil {
		panic("MongoDBMock.UnlockInstanceFunc: method is nil but MongoDB.UnlockInstance was just called")
	}
	callInfo := struct {
		LockID string
	}{
		LockID: lockID,
	}
	lockMongoDBMockUnlockInstance.Lock()
	mock.calls.UnlockInstance = append(mock.calls.UnlockInstance, callInfo)
	lockMongoDBMockUnlockInstance.Unlock()
	return mock.UnlockInstanceFunc(lockID)
}

// UnlockInstanceCalls gets all the calls that were made to UnlockInstance.
// Check the length with:
//     len(mockedMongoDB.UnlockInstanceCalls())
func (mock *MongoDBMock) UnlockInstanceCalls() []struct {
	LockID string
} {
	var calls []struct {
		LockID string
	}
	lockMongoDBMockUnlockInstance.RLock()
	calls = mock.calls.UnlockInstance
	lockMongoDBMockUnlockInstance.RUnlock()
	return calls
}

// UpdateBuildHierarchyTaskState calls UpdateBuildHierarchyTaskStateFunc.
func (mock *MongoDBMock) UpdateBuildHierarchyTaskState(currentInstance *models.Instance, dimension string, state string, eTagSelector string) (string, error) {
	if mock.UpdateBuildHierarchyTaskStateFunc == nil {
		panic("MongoDBMock.UpdateBuildHierarchyTaskStateFunc: method is nil but MongoDB.UpdateBuildHierarchyTaskState was just called")
	}
	callInfo := struct {
		CurrentInstance *models.Instance
		Dimension       string
		State           string
		ETagSelector    string
	}{
		CurrentInstance: currentInstance,
		Dimension:       dimension,
		State:           state,
		ETagSelector:    eTagSelector,
	}
	lockMongoDBMockUpdateBuildHierarchyTaskState.Lock()
	mock.calls.UpdateBuildHierarchyTaskState = append(mock.calls.UpdateBuildHierarchyTaskState, callInfo)
	lockMongoDBMockUpdateBuildHierarchyTaskState.Unlock()
	return mock.UpdateBuildHierarchyTaskStateFunc(currentInstance, dimension, state, eTagSelector)
}

// UpdateBuildHierarchyTaskStateCalls gets all the calls that were made to UpdateBuildHierarchyTaskState.
// Check the length with:
//     len(mockedMongoDB.UpdateBuildHierarchyTaskStateCalls())
func (mock *MongoDBMock) UpdateBuildHierarchyTaskStateCalls() []struct {
	CurrentInstance *models.Instance
	Dimension       string
	State           string
	ETagSelector    string
} {
	var calls []struct {
		CurrentInstance *models.Instance
		Dimension       string
		State           string
		ETagSelector    string
	}
	lockMongoDBMockUpdateBuildHierarchyTaskState.RLock()
	calls = mock.calls.UpdateBuildHierarchyTaskState
	lockMongoDBMockUpdateBuildHierarchyTaskState.RUnlock()
	return calls
}

// UpdateBuildSearchTaskState calls UpdateBuildSearchTaskStateFunc.
func (mock *MongoDBMock) UpdateBuildSearchTaskState(currentInstance *models.Instance, dimension string, state string, eTagSelector string) (string, error) {
	if mock.UpdateBuildSearchTaskStateFunc == nil {
		panic("MongoDBMock.UpdateBuildSearchTaskStateFunc: method is nil but MongoDB.UpdateBuildSearchTaskState was just called")
	}
	callInfo := struct {
		CurrentInstance *models.Instance
		Dimension       string
		State           string
		ETagSelector    string
	}{
		CurrentInstance: currentInstance,
		Dimension:       dimension,
		State:           state,
		ETagSelector:    eTagSelector,
	}
	lockMongoDBMockUpdateBuildSearchTaskState.Lock()
	mock.calls.UpdateBuildSearchTaskState = append(mock.calls.UpdateBuildSearchTaskState, callInfo)
	lockMongoDBMockUpdateBuildSearchTaskState.Unlock()
	return mock.UpdateBuildSearchTaskStateFunc(currentInstance, dimension, state, eTagSelector)
}

// UpdateBuildSearchTaskStateCalls gets all the calls that were made to UpdateBuildSearchTaskState.
// Check the length with:
//     len(mockedMongoDB.UpdateBuildSearchTaskStateCalls())
func (mock *MongoDBMock) UpdateBuildSearchTaskStateCalls() []struct {
	CurrentInstance *models.Instance
	Dimension       string
	State           string
	ETagSelector    string
} {
	var calls []struct {
		CurrentInstance *models.Instance
		Dimension       string
		State           string
		ETagSelector    string
	}
	lockMongoDBMockUpdateBuildSearchTaskState.RLock()
	calls = mock.calls.UpdateBuildSearchTaskState
	lockMongoDBMockUpdateBuildSearchTaskState.RUnlock()
	return calls
}

// UpdateDataset calls UpdateDatasetFunc.
func (mock *MongoDBMock) UpdateDataset(ctx context.Context, ID string, dataset *models.Dataset, currentState string) error {
	if mock.UpdateDatasetFunc == nil {
		panic("MongoDBMock.UpdateDatasetFunc: method is nil but MongoDB.UpdateDataset was just called")
	}
	callInfo := struct {
		Ctx          context.Context
		ID           string
		Dataset      *models.Dataset
		CurrentState string
	}{
		Ctx:          ctx,
		ID:           ID,
		Dataset:      dataset,
		CurrentState: currentState,
	}
	lockMongoDBMockUpdateDataset.Lock()
	mock.calls.UpdateDataset = append(mock.calls.UpdateDataset, callInfo)
	lockMongoDBMockUpdateDataset.Unlock()
	return mock.UpdateDatasetFunc(ctx, ID, dataset, currentState)
}

// UpdateDatasetCalls gets all the calls that were made to UpdateDataset.
// Check the length with:
//     len(mockedMongoDB.UpdateDatasetCalls())
func (mock *MongoDBMock) UpdateDatasetCalls() []struct {
	Ctx          context.Context
	ID           string
	Dataset      *models.Dataset
	CurrentState string
} {
	var calls []struct {
		Ctx          context.Context
		ID           string
		Dataset      *models.Dataset
		CurrentState string
	}
	lockMongoDBMockUpdateDataset.RLock()
	calls = mock.calls.UpdateDataset
	lockMongoDBMockUpdateDataset.RUnlock()
	return calls
}

// UpdateDatasetWithAssociation calls UpdateDatasetWithAssociationFunc.
func (mock *MongoDBMock) UpdateDatasetWithAssociation(ID string, state string, version *models.Version) error {
	if mock.UpdateDatasetWithAssociationFunc == nil {
		panic("MongoDBMock.UpdateDatasetWithAssociationFunc: method is nil but MongoDB.UpdateDatasetWithAssociation was just called")
	}
	callInfo := struct {
		ID      string
		State   string
		Version *models.Version
	}{
		ID:      ID,
		State:   state,
		Version: version,
	}
	lockMongoDBMockUpdateDatasetWithAssociation.Lock()
	mock.calls.UpdateDatasetWithAssociation = append(mock.calls.UpdateDatasetWithAssociation, callInfo)
	lockMongoDBMockUpdateDatasetWithAssociation.Unlock()
	return mock.UpdateDatasetWithAssociationFunc(ID, state, version)
}

// UpdateDatasetWithAssociationCalls gets all the calls that were made to UpdateDatasetWithAssociation.
// Check the length with:
//     len(mockedMongoDB.UpdateDatasetWithAssociationCalls())
func (mock *MongoDBMock) UpdateDatasetWithAssociationCalls() []struct {
	ID      string
	State   string
	Version *models.Version
} {
	var calls []struct {
		ID      string
		State   string
		Version *models.Version
	}
	lockMongoDBMockUpdateDatasetWithAssociation.RLock()
	calls = mock.calls.UpdateDatasetWithAssociation
	lockMongoDBMockUpdateDatasetWithAssociation.RUnlock()
	return calls
}

// UpdateDimensionNodeIDAndOrder calls UpdateDimensionNodeIDAndOrderFunc.
func (mock *MongoDBMock) UpdateDimensionNodeIDAndOrder(dimension *models.DimensionOption) error {
	if mock.UpdateDimensionNodeIDAndOrderFunc == nil {
		panic("MongoDBMock.UpdateDimensionNodeIDAndOrderFunc: method is nil but MongoDB.UpdateDimensionNodeIDAndOrder was just called")
	}
	callInfo := struct {
		Dimension *models.DimensionOption
	}{
		Dimension: dimension,
	}
	lockMongoDBMockUpdateDimensionNodeIDAndOrder.Lock()
	mock.calls.UpdateDimensionNodeIDAndOrder = append(mock.calls.UpdateDimensionNodeIDAndOrder, callInfo)
	lockMongoDBMockUpdateDimensionNodeIDAndOrder.Unlock()
	return mock.UpdateDimensionNodeIDAndOrderFunc(dimension)
}

// UpdateDimensionNodeIDAndOrderCalls gets all the calls that were made to UpdateDimensionNodeIDAndOrder.
// Check the length with:
//     len(mockedMongoDB.UpdateDimensionNodeIDAndOrderCalls())
func (mock *MongoDBMock) UpdateDimensionNodeIDAndOrderCalls() []struct {
	Dimension *models.DimensionOption
} {
	var calls []struct {
		Dimension *models.DimensionOption
	}
	lockMongoDBMockUpdateDimensionNodeIDAndOrder.RLock()
	calls = mock.calls.UpdateDimensionNodeIDAndOrder
	lockMongoDBMockUpdateDimensionNodeIDAndOrder.RUnlock()
	return calls
}

// UpdateETagForNodeIDAndOrder calls UpdateETagForNodeIDAndOrderFunc.
func (mock *MongoDBMock) UpdateETagForNodeIDAndOrder(currentInstance *models.Instance, nodeID string, order *int, eTagSelector string) (string, error) {
	if mock.UpdateETagForNodeIDAndOrderFunc == nil {
		panic("MongoDBMock.UpdateETagForNodeIDAndOrderFunc: method is nil but MongoDB.UpdateETagForNodeIDAndOrder was just called")
	}
	callInfo := struct {
		CurrentInstance *models.Instance
		NodeID          string
		Order           *int
		ETagSelector    string
	}{
		CurrentInstance: currentInstance,
		NodeID:          nodeID,
		Order:           order,
		ETagSelector:    eTagSelector,
	}
	lockMongoDBMockUpdateETagForNodeIDAndOrder.Lock()
	mock.calls.UpdateETagForNodeIDAndOrder = append(mock.calls.UpdateETagForNodeIDAndOrder, callInfo)
	lockMongoDBMockUpdateETagForNodeIDAndOrder.Unlock()
	return mock.UpdateETagForNodeIDAndOrderFunc(currentInstance, nodeID, order, eTagSelector)
}

// UpdateETagForNodeIDAndOrderCalls gets all the calls that were made to UpdateETagForNodeIDAndOrder.
// Check the length with:
//     len(mockedMongoDB.UpdateETagForNodeIDAndOrderCalls())
func (mock *MongoDBMock) UpdateETagForNodeIDAndOrderCalls() []struct {
	CurrentInstance *models.Instance
	NodeID          string
	Order           *int
	ETagSelector    string
} {
	var calls []struct {
		CurrentInstance *models.Instance
		NodeID          string
		Order           *int
		ETagSelector    string
	}
	lockMongoDBMockUpdateETagForNodeIDAndOrder.RLock()
	calls = mock.calls.UpdateETagForNodeIDAndOrder
	lockMongoDBMockUpdateETagForNodeIDAndOrder.RUnlock()
	return calls
}

// UpdateETagForOptions calls UpdateETagForOptionsFunc.
func (mock *MongoDBMock) UpdateETagForOptions(currentInstance *models.Instance, option *models.CachedDimensionOption, eTagSelector string) (string, error) {
	if mock.UpdateETagForOptionsFunc == nil {
		panic("MongoDBMock.UpdateETagForOptionsFunc: method is nil but MongoDB.UpdateETagForOptions was just called")
	}
	callInfo := struct {
		CurrentInstance *models.Instance
		Option          *models.CachedDimensionOption
		ETagSelector    string
	}{
		CurrentInstance: currentInstance,
		Option:          option,
		ETagSelector:    eTagSelector,
	}
	lockMongoDBMockUpdateETagForOptions.Lock()
	mock.calls.UpdateETagForOptions = append(mock.calls.UpdateETagForOptions, callInfo)
	lockMongoDBMockUpdateETagForOptions.Unlock()
	return mock.UpdateETagForOptionsFunc(currentInstance, option, eTagSelector)
}

// UpdateETagForOptionsCalls gets all the calls that were made to UpdateETagForOptions.
// Check the length with:
//     len(mockedMongoDB.UpdateETagForOptionsCalls())
func (mock *MongoDBMock) UpdateETagForOptionsCalls() []struct {
	CurrentInstance *models.Instance
	Option          *models.CachedDimensionOption
	ETagSelector    string
} {
	var calls []struct {
		CurrentInstance *models.Instance
		Option          *models.CachedDimensionOption
		ETagSelector    string
	}
	lockMongoDBMockUpdateETagForOptions.RLock()
	calls = mock.calls.UpdateETagForOptions
	lockMongoDBMockUpdateETagForOptions.RUnlock()
	return calls
}

// UpdateImportObservationsTaskState calls UpdateImportObservationsTaskStateFunc.
func (mock *MongoDBMock) UpdateImportObservationsTaskState(currentInstance *models.Instance, state string, eTagSelector string) (string, error) {
	if mock.UpdateImportObservationsTaskStateFunc == nil {
		panic("MongoDBMock.UpdateImportObservationsTaskStateFunc: method is nil but MongoDB.UpdateImportObservationsTaskState was just called")
	}
	callInfo := struct {
		CurrentInstance *models.Instance
		State           string
		ETagSelector    string
	}{
		CurrentInstance: currentInstance,
		State:           state,
		ETagSelector:    eTagSelector,
	}
	lockMongoDBMockUpdateImportObservationsTaskState.Lock()
	mock.calls.UpdateImportObservationsTaskState = append(mock.calls.UpdateImportObservationsTaskState, callInfo)
	lockMongoDBMockUpdateImportObservationsTaskState.Unlock()
	return mock.UpdateImportObservationsTaskStateFunc(currentInstance, state, eTagSelector)
}

// UpdateImportObservationsTaskStateCalls gets all the calls that were made to UpdateImportObservationsTaskState.
// Check the length with:
//     len(mockedMongoDB.UpdateImportObservationsTaskStateCalls())
func (mock *MongoDBMock) UpdateImportObservationsTaskStateCalls() []struct {
	CurrentInstance *models.Instance
	State           string
	ETagSelector    string
} {
	var calls []struct {
		CurrentInstance *models.Instance
		State           string
		ETagSelector    string
	}
	lockMongoDBMockUpdateImportObservationsTaskState.RLock()
	calls = mock.calls.UpdateImportObservationsTaskState
	lockMongoDBMockUpdateImportObservationsTaskState.RUnlock()
	return calls
}

// UpdateInstance calls UpdateInstanceFunc.
func (mock *MongoDBMock) UpdateInstance(ctx context.Context, currentInstance *models.Instance, updatedInstance *models.Instance, eTagSelector string) (string, error) {
	if mock.UpdateInstanceFunc == nil {
		panic("MongoDBMock.UpdateInstanceFunc: method is nil but MongoDB.UpdateInstance was just called")
	}
	callInfo := struct {
		Ctx             context.Context
		CurrentInstance *models.Instance
		UpdatedInstance *models.Instance
		ETagSelector    string
	}{
		Ctx:             ctx,
		CurrentInstance: currentInstance,
		UpdatedInstance: updatedInstance,
		ETagSelector:    eTagSelector,
	}
	lockMongoDBMockUpdateInstance.Lock()
	mock.calls.UpdateInstance = append(mock.calls.UpdateInstance, callInfo)
	lockMongoDBMockUpdateInstance.Unlock()
	return mock.UpdateInstanceFunc(ctx, currentInstance, updatedInstance, eTagSelector)
}

// UpdateInstanceCalls gets all the calls that were made to UpdateInstance.
// Check the length with:
//     len(mockedMongoDB.UpdateInstanceCalls())
func (mock *MongoDBMock) UpdateInstanceCalls() []struct {
	Ctx             context.Context
	CurrentInstance *models.Instance
	UpdatedInstance *models.Instance
	ETagSelector    string
} {
	var calls []struct {
		Ctx             context.Context
		CurrentInstance *models.Instance
		UpdatedInstance *models.Instance
		ETagSelector    string
	}
	lockMongoDBMockUpdateInstance.RLock()
	calls = mock.calls.UpdateInstance
	lockMongoDBMockUpdateInstance.RUnlock()
	return calls
}

// UpdateObservationInserted calls UpdateObservationInsertedFunc.
func (mock *MongoDBMock) UpdateObservationInserted(currentInstance *models.Instance, observationInserted int64, eTagSelector string) (string, error) {
	if mock.UpdateObservationInsertedFunc == nil {
		panic("MongoDBMock.UpdateObservationInsertedFunc: method is nil but MongoDB.UpdateObservationInserted was just called")
	}
	callInfo := struct {
		CurrentInstance     *models.Instance
		ObservationInserted int64
		ETagSelector        string
	}{
		CurrentInstance:     currentInstance,
		ObservationInserted: observationInserted,
		ETagSelector:        eTagSelector,
	}
	lockMongoDBMockUpdateObservationInserted.Lock()
	mock.calls.UpdateObservationInserted = append(mock.calls.UpdateObservationInserted, callInfo)
	lockMongoDBMockUpdateObservationInserted.Unlock()
	return mock.UpdateObservationInsertedFunc(currentInstance, observationInserted, eTagSelector)
}

// UpdateObservationInsertedCalls gets all the calls that were made to UpdateObservationInserted.
// Check the length with:
//     len(mockedMongoDB.UpdateObservationInsertedCalls())
func (mock *MongoDBMock) UpdateObservationInsertedCalls() []struct {
	CurrentInstance     *models.Instance
	ObservationInserted int64
	ETagSelector        string
} {
	var calls []struct {
		CurrentInstance     *models.Instance
		ObservationInserted int64
		ETagSelector        string
	}
	lockMongoDBMockUpdateObservationInserted.RLock()
	calls = mock.calls.UpdateObservationInserted
	lockMongoDBMockUpdateObservationInserted.RUnlock()
	return calls
}

// UpdateVersion calls UpdateVersionFunc.
func (mock *MongoDBMock) UpdateVersion(ID string, version *models.Version) error {
	if mock.UpdateVersionFunc == nil {
		panic("MongoDBMock.UpdateVersionFunc: method is nil but MongoDB.UpdateVersion was just called")
	}
	callInfo := struct {
		ID      string
		Version *models.Version
	}{
		ID:      ID,
		Version: version,
	}
	lockMongoDBMockUpdateVersion.Lock()
	mock.calls.UpdateVersion = append(mock.calls.UpdateVersion, callInfo)
	lockMongoDBMockUpdateVersion.Unlock()
	return mock.UpdateVersionFunc(ID, version)
}

// UpdateVersionCalls gets all the calls that were made to UpdateVersion.
// Check the length with:
//     len(mockedMongoDB.UpdateVersionCalls())
func (mock *MongoDBMock) UpdateVersionCalls() []struct {
	ID      string
	Version *models.Version
} {
	var calls []struct {
		ID      string
		Version *models.Version
	}
	lockMongoDBMockUpdateVersion.RLock()
	calls = mock.calls.UpdateVersion
	lockMongoDBMockUpdateVersion.RUnlock()
	return calls
}

// UpsertContact calls UpsertContactFunc.
func (mock *MongoDBMock) UpsertContact(ID string, update interface{}) error {
	if mock.UpsertContactFunc == nil {
		panic("MongoDBMock.UpsertContactFunc: method is nil but MongoDB.UpsertContact was just called")
	}
	callInfo := struct {
		ID     string
		Update interface{}
	}{
		ID:     ID,
		Update: update,
	}
	lockMongoDBMockUpsertContact.Lock()
	mock.calls.UpsertContact = append(mock.calls.UpsertContact, callInfo)
	lockMongoDBMockUpsertContact.Unlock()
	return mock.UpsertContactFunc(ID, update)
}

// UpsertContactCalls gets all the calls that were made to UpsertContact.
// Check the length with:
//     len(mockedMongoDB.UpsertContactCalls())
func (mock *MongoDBMock) UpsertContactCalls() []struct {
	ID     string
	Update interface{}
} {
	var calls []struct {
		ID     string
		Update interface{}
	}
	lockMongoDBMockUpsertContact.RLock()
	calls = mock.calls.UpsertContact
	lockMongoDBMockUpsertContact.RUnlock()
	return calls
}

// UpsertDataset calls UpsertDatasetFunc.
func (mock *MongoDBMock) UpsertDataset(ID string, datasetDoc *models.DatasetUpdate) error {
	if mock.UpsertDatasetFunc == nil {
		panic("MongoDBMock.UpsertDatasetFunc: method is nil but MongoDB.UpsertDataset was just called")
	}
	callInfo := struct {
		ID         string
		DatasetDoc *models.DatasetUpdate
	}{
		ID:         ID,
		DatasetDoc: datasetDoc,
	}
	lockMongoDBMockUpsertDataset.Lock()
	mock.calls.UpsertDataset = append(mock.calls.UpsertDataset, callInfo)
	lockMongoDBMockUpsertDataset.Unlock()
	return mock.UpsertDatasetFunc(ID, datasetDoc)
}

// UpsertDatasetCalls gets all the calls that were made to UpsertDataset.
// Check the length with:
//     len(mockedMongoDB.UpsertDatasetCalls())
func (mock *MongoDBMock) UpsertDatasetCalls() []struct {
	ID         string
	DatasetDoc *models.DatasetUpdate
} {
	var calls []struct {
		ID         string
		DatasetDoc *models.DatasetUpdate
	}
	lockMongoDBMockUpsertDataset.RLock()
	calls = mock.calls.UpsertDataset
	lockMongoDBMockUpsertDataset.RUnlock()
	return calls
}

// UpsertEdition calls UpsertEditionFunc.
func (mock *MongoDBMock) UpsertEdition(datasetID string, edition string, editionDoc *models.EditionUpdate) error {
	if mock.UpsertEditionFunc == nil {
		panic("MongoDBMock.UpsertEditionFunc: method is nil but MongoDB.UpsertEdition was just called")
	}
	callInfo := struct {
		DatasetID  string
		Edition    string
		EditionDoc *models.EditionUpdate
	}{
		DatasetID:  datasetID,
		Edition:    edition,
		EditionDoc: editionDoc,
	}
	lockMongoDBMockUpsertEdition.Lock()
	mock.calls.UpsertEdition = append(mock.calls.UpsertEdition, callInfo)
	lockMongoDBMockUpsertEdition.Unlock()
	return mock.UpsertEditionFunc(datasetID, edition, editionDoc)
}

// UpsertEditionCalls gets all the calls that were made to UpsertEdition.
// Check the length with:
//     len(mockedMongoDB.UpsertEditionCalls())
func (mock *MongoDBMock) UpsertEditionCalls() []struct {
	DatasetID  string
	Edition    string
	EditionDoc *models.EditionUpdate
} {
	var calls []struct {
		DatasetID  string
		Edition    string
		EditionDoc *models.EditionUpdate
	}
	lockMongoDBMockUpsertEdition.RLock()
	calls = mock.calls.UpsertEdition
	lockMongoDBMockUpsertEdition.RUnlock()
	return calls
}

// UpsertVersion calls UpsertVersionFunc.
func (mock *MongoDBMock) UpsertVersion(ID string, versionDoc *models.Version) error {
	if mock.UpsertVersionFunc == nil {
		panic("MongoDBMock.UpsertVersionFunc: method is nil but MongoDB.UpsertVersion was just called")
	}
	callInfo := struct {
		ID         string
		VersionDoc *models.Version
	}{
		ID:         ID,
		VersionDoc: versionDoc,
	}
	lockMongoDBMockUpsertVersion.Lock()
	mock.calls.UpsertVersion = append(mock.calls.UpsertVersion, callInfo)
	lockMongoDBMockUpsertVersion.Unlock()
	return mock.UpsertVersionFunc(ID, versionDoc)
}

// UpsertVersionCalls gets all the calls that were made to UpsertVersion.
// Check the length with:
//     len(mockedMongoDB.UpsertVersionCalls())
func (mock *MongoDBMock) UpsertVersionCalls() []struct {
	ID         string
	VersionDoc *models.Version
} {
	var calls []struct {
		ID         string
		VersionDoc *models.Version
	}
	lockMongoDBMockUpsertVersion.RLock()
	calls = mock.calls.UpsertVersion
	lockMongoDBMockUpsertVersion.RUnlock()
	return calls
}
