// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package storetest

import (
	"context"
	"github.com/ONSdigital/dp-dataset-api/models"
	"github.com/ONSdigital/dp-dataset-api/store"
	"go.mongodb.org/mongo-driver/bson"
	"sync"
)

// Ensure, that StorerMock does implement store.Storer.
// If this is not the case, regenerate this file with moq.
var _ store.Storer = &StorerMock{}

// StorerMock is a mock implementation of store.Storer.
//
//	func TestSomethingThatUsesStorer(t *testing.T) {
//
//		// make and configure a mocked store.Storer
//		mockedStorer := &StorerMock{
//			AcquireInstanceLockFunc: func(ctx context.Context, instanceID string) (string, error) {
//				panic("mock out the AcquireInstanceLock method")
//			},
//			AcquireVersionsLockFunc: func(ctx context.Context, versionID string) (string, error) {
//				panic("mock out the AcquireVersionsLock method")
//			},
//			AddEventToInstanceFunc: func(ctx context.Context, currentInstance *models.Instance, event *models.Event, eTagSelector string) (string, error) {
//				panic("mock out the AddEventToInstance method")
//			},
//			AddInstanceFunc: func(ctx context.Context, instance *models.Instance) (*models.Instance, error) {
//				panic("mock out the AddInstance method")
//			},
//			AddVersionDetailsToInstanceFunc: func(ctx context.Context, instanceID string, datasetID string, edition string, version int) error {
//				panic("mock out the AddVersionDetailsToInstance method")
//			},
//			AddVersionStaticFunc: func(ctx context.Context, version *models.Version) (*models.Version, error) {
//				panic("mock out the AddVersionStatic method")
//			},
//			CheckDatasetExistsFunc: func(ctx context.Context, ID string, state string) error {
//				panic("mock out the CheckDatasetExists method")
//			},
//			CheckDatasetTitleExistFunc: func(ctx context.Context, title string) (bool, error) {
//				panic("mock out the CheckDatasetTitleExist method")
//			},
//			CheckEditionExistsFunc: func(ctx context.Context, ID string, editionID string, state string) error {
//				panic("mock out the CheckEditionExists method")
//			},
//			CheckEditionExistsStaticFunc: func(ctx context.Context, id string, editionID string, state string) error {
//				panic("mock out the CheckEditionExistsStatic method")
//			},
//			DeleteDatasetFunc: func(ctx context.Context, ID string) error {
//				panic("mock out the DeleteDataset method")
//			},
//			DeleteEditionFunc: func(ctx context.Context, ID string) error {
//				panic("mock out the DeleteEdition method")
//			},
//			GetAllStaticVersionsFunc: func(ctx context.Context, ID string, state string, offset int, limit int) ([]*models.Version, int, error) {
//				panic("mock out the GetAllStaticVersions method")
//			},
//			GetDatasetFunc: func(ctx context.Context, ID string) (*models.DatasetUpdate, error) {
//				panic("mock out the GetDataset method")
//			},
//			GetDatasetTypeFunc: func(ctx context.Context, datasetID string, authorised bool) (string, error) {
//				panic("mock out the GetDatasetType method")
//			},
//			GetDatasetsFunc: func(ctx context.Context, offset int, limit int, authorised bool) ([]*models.DatasetUpdate, int, error) {
//				panic("mock out the GetDatasets method")
//			},
//			GetDatasetsByQueryParamsFunc: func(ctx context.Context, ID string, datasetType string, offset int, limit int, authorised bool) ([]*models.DatasetUpdate, int, error) {
//				panic("mock out the GetDatasetsByQueryParams method")
//			},
//			GetDimensionOptionsFunc: func(ctx context.Context, version *models.Version, dimension string, offset int, limit int) ([]*models.PublicDimensionOption, int, error) {
//				panic("mock out the GetDimensionOptions method")
//			},
//			GetDimensionOptionsFromIDsFunc: func(ctx context.Context, version *models.Version, dimension string, ids []string) ([]*models.PublicDimensionOption, int, error) {
//				panic("mock out the GetDimensionOptionsFromIDs method")
//			},
//			GetDimensionsFunc: func(ctx context.Context, versionID string) ([]bson.M, error) {
//				panic("mock out the GetDimensions method")
//			},
//			GetDimensionsFromInstanceFunc: func(ctx context.Context, ID string, offset int, limit int) ([]*models.DimensionOption, int, error) {
//				panic("mock out the GetDimensionsFromInstance method")
//			},
//			GetEditionFunc: func(ctx context.Context, ID string, editionID string, state string) (*models.EditionUpdate, error) {
//				panic("mock out the GetEdition method")
//			},
//			GetEditionsFunc: func(ctx context.Context, ID string, state string, offset int, limit int, authorised bool) ([]*models.EditionUpdate, int, error) {
//				panic("mock out the GetEditions method")
//			},
//			GetInstanceFunc: func(ctx context.Context, ID string, eTagSelector string) (*models.Instance, error) {
//				panic("mock out the GetInstance method")
//			},
//			GetInstancesFunc: func(ctx context.Context, states []string, datasets []string, offset int, limit int) ([]*models.Instance, int, error) {
//				panic("mock out the GetInstances method")
//			},
//			GetLatestStaticVersionByStateFunc: func(ctx context.Context, datasetID string, edition string, state string) (*models.Version, error) {
//				panic("mock out the GetLatestStaticVersionByState method")
//			},
//			GetLatestVersionStaticFunc: func(ctx context.Context, datasetID string, editionID string, state string) (*models.Version, error) {
//				panic("mock out the GetLatestVersionStatic method")
//			},
//			GetNextVersionFunc: func(ctx context.Context, datasetID string, editionID string) (int, error) {
//				panic("mock out the GetNextVersion method")
//			},
//			GetStaticEditionsByStateFunc: func(ctx context.Context, state string, offset int, limit int) ([]*models.Version, int, error) {
//				panic("mock out the GetStaticEditionsByState method")
//			},
//			GetUniqueDimensionAndOptionsFunc: func(ctx context.Context, ID string, dimension string) ([]*string, int, error) {
//				panic("mock out the GetUniqueDimensionAndOptions method")
//			},
//			GetUnpublishedDatasetStaticFunc: func(ctx context.Context, id string) (*models.Dataset, error) {
//				panic("mock out the GetUnpublishedDatasetStatic method")
//			},
//			GetVersionFunc: func(ctx context.Context, datasetID string, editionID string, version int, state string) (*models.Version, error) {
//				panic("mock out the GetVersion method")
//			},
//			GetVersionStaticFunc: func(ctx context.Context, datasetID string, editionID string, version int, state string) (*models.Version, error) {
//				panic("mock out the GetVersionStatic method")
//			},
//			GetVersionsFunc: func(ctx context.Context, datasetID string, editionID string, state string, offset int, limit int) ([]models.Version, int, error) {
//				panic("mock out the GetVersions method")
//			},
//			GetVersionsStaticFunc: func(ctx context.Context, datasetID string, edition string, state string, offset int, limit int) ([]models.Version, int, error) {
//				panic("mock out the GetVersionsStatic method")
//			},
//			RemoveDatasetVersionAndEditionLinksFunc: func(ctx context.Context, id string) error {
//				panic("mock out the RemoveDatasetVersionAndEditionLinks method")
//			},
//			SetInstanceIsPublishedFunc: func(ctx context.Context, instanceID string) error {
//				panic("mock out the SetInstanceIsPublished method")
//			},
//			UnlockInstanceFunc: func(ctx context.Context, lockID string)  {
//				panic("mock out the UnlockInstance method")
//			},
//			UnlockVersionsFunc: func(ctx context.Context, lockID string)  {
//				panic("mock out the UnlockVersions method")
//			},
//			UpdateBuildHierarchyTaskStateFunc: func(ctx context.Context, currentInstance *models.Instance, dimension string, state string, eTagSelector string) (string, error) {
//				panic("mock out the UpdateBuildHierarchyTaskState method")
//			},
//			UpdateBuildSearchTaskStateFunc: func(ctx context.Context, currentInstance *models.Instance, dimension string, state string, eTagSelector string) (string, error) {
//				panic("mock out the UpdateBuildSearchTaskState method")
//			},
//			UpdateDatasetFunc: func(ctx context.Context, ID string, dataset *models.Dataset, currentState string) error {
//				panic("mock out the UpdateDataset method")
//			},
//			UpdateDatasetWithAssociationFunc: func(ctx context.Context, ID string, state string, version *models.Version) error {
//				panic("mock out the UpdateDatasetWithAssociation method")
//			},
//			UpdateDimensionsNodeIDAndOrderFunc: func(ctx context.Context, updates []*models.DimensionOption) error {
//				panic("mock out the UpdateDimensionsNodeIDAndOrder method")
//			},
//			UpdateETagForOptionsFunc: func(ctx context.Context, currentInstance *models.Instance, upserts []*models.CachedDimensionOption, updates []*models.DimensionOption, eTagSelector string) (string, error) {
//				panic("mock out the UpdateETagForOptions method")
//			},
//			UpdateImportObservationsTaskStateFunc: func(ctx context.Context, currentInstance *models.Instance, state string, eTagSelector string) (string, error) {
//				panic("mock out the UpdateImportObservationsTaskState method")
//			},
//			UpdateInstanceFunc: func(ctx context.Context, currentInstance *models.Instance, updatedInstance *models.Instance, eTagSelector string) (string, error) {
//				panic("mock out the UpdateInstance method")
//			},
//			UpdateMetadataFunc: func(ctx context.Context, datasetID string, versionID string, versionEtag string, updatedDataset *models.Dataset, updatedVersion *models.Version) error {
//				panic("mock out the UpdateMetadata method")
//			},
//			UpdateObservationInsertedFunc: func(ctx context.Context, currentInstance *models.Instance, observationInserted int64, eTagSelector string) (string, error) {
//				panic("mock out the UpdateObservationInserted method")
//			},
//			UpdateVersionFunc: func(ctx context.Context, currentVersion *models.Version, version *models.Version, eTagSelector string) (string, error) {
//				panic("mock out the UpdateVersion method")
//			},
//			UpdateVersionStaticFunc: func(ctx context.Context, currentVersion *models.Version, versionUpdate *models.Version, eTagSelector string) (string, error) {
//				panic("mock out the UpdateVersionStatic method")
//			},
//			UpsertContactFunc: func(ctx context.Context, ID string, update interface{}) error {
//				panic("mock out the UpsertContact method")
//			},
//			UpsertDatasetFunc: func(ctx context.Context, ID string, datasetDoc *models.DatasetUpdate) error {
//				panic("mock out the UpsertDataset method")
//			},
//			UpsertDimensionsToInstanceFunc: func(ctx context.Context, dimensions []*models.CachedDimensionOption) error {
//				panic("mock out the UpsertDimensionsToInstance method")
//			},
//			UpsertEditionFunc: func(ctx context.Context, datasetID string, edition string, editionDoc *models.EditionUpdate) error {
//				panic("mock out the UpsertEdition method")
//			},
//			UpsertVersionFunc: func(ctx context.Context, ID string, versionDoc *models.Version) error {
//				panic("mock out the UpsertVersion method")
//			},
//			UpsertVersionStaticFunc: func(ctx context.Context, ID string, versionDoc *models.Version) error {
//				panic("mock out the UpsertVersionStatic method")
//			},
//		}
//
//		// use mockedStorer in code that requires store.Storer
//		// and then make assertions.
//
//	}
type StorerMock struct {
	// AcquireInstanceLockFunc mocks the AcquireInstanceLock method.
	AcquireInstanceLockFunc func(ctx context.Context, instanceID string) (string, error)

	// AcquireVersionsLockFunc mocks the AcquireVersionsLock method.
	AcquireVersionsLockFunc func(ctx context.Context, versionID string) (string, error)

	// AddEventToInstanceFunc mocks the AddEventToInstance method.
	AddEventToInstanceFunc func(ctx context.Context, currentInstance *models.Instance, event *models.Event, eTagSelector string) (string, error)

	// AddInstanceFunc mocks the AddInstance method.
	AddInstanceFunc func(ctx context.Context, instance *models.Instance) (*models.Instance, error)

	// AddVersionDetailsToInstanceFunc mocks the AddVersionDetailsToInstance method.
	AddVersionDetailsToInstanceFunc func(ctx context.Context, instanceID string, datasetID string, edition string, version int) error

	// AddVersionStaticFunc mocks the AddVersionStatic method.
	AddVersionStaticFunc func(ctx context.Context, version *models.Version) (*models.Version, error)

	// CheckDatasetExistsFunc mocks the CheckDatasetExists method.
	CheckDatasetExistsFunc func(ctx context.Context, ID string, state string) error

	// CheckDatasetTitleExistFunc mocks the CheckDatasetTitleExist method.
	CheckDatasetTitleExistFunc func(ctx context.Context, title string) (bool, error)

	// CheckEditionExistsFunc mocks the CheckEditionExists method.
	CheckEditionExistsFunc func(ctx context.Context, ID string, editionID string, state string) error

	// CheckEditionExistsStaticFunc mocks the CheckEditionExistsStatic method.
	CheckEditionExistsStaticFunc func(ctx context.Context, id string, editionID string, state string) error

	// DeleteDatasetFunc mocks the DeleteDataset method.
	DeleteDatasetFunc func(ctx context.Context, ID string) error

	// DeleteEditionFunc mocks the DeleteEdition method.
	DeleteEditionFunc func(ctx context.Context, ID string) error

	// GetAllStaticVersionsFunc mocks the GetAllStaticVersions method.
	GetAllStaticVersionsFunc func(ctx context.Context, ID string, state string, offset int, limit int) ([]*models.Version, int, error)

	// GetDatasetFunc mocks the GetDataset method.
	GetDatasetFunc func(ctx context.Context, ID string) (*models.DatasetUpdate, error)

	// GetDatasetTypeFunc mocks the GetDatasetType method.
	GetDatasetTypeFunc func(ctx context.Context, datasetID string, authorised bool) (string, error)

	// GetDatasetsFunc mocks the GetDatasets method.
	GetDatasetsFunc func(ctx context.Context, offset int, limit int, authorised bool) ([]*models.DatasetUpdate, int, error)

	// GetDatasetsByQueryParamsFunc mocks the GetDatasetsByQueryParams method.
	GetDatasetsByQueryParamsFunc func(ctx context.Context, ID string, datasetType string, offset int, limit int, authorised bool) ([]*models.DatasetUpdate, int, error)

	// GetDimensionOptionsFunc mocks the GetDimensionOptions method.
	GetDimensionOptionsFunc func(ctx context.Context, version *models.Version, dimension string, offset int, limit int) ([]*models.PublicDimensionOption, int, error)

	// GetDimensionOptionsFromIDsFunc mocks the GetDimensionOptionsFromIDs method.
	GetDimensionOptionsFromIDsFunc func(ctx context.Context, version *models.Version, dimension string, ids []string) ([]*models.PublicDimensionOption, int, error)

	// GetDimensionsFunc mocks the GetDimensions method.
	GetDimensionsFunc func(ctx context.Context, versionID string) ([]bson.M, error)

	// GetDimensionsFromInstanceFunc mocks the GetDimensionsFromInstance method.
	GetDimensionsFromInstanceFunc func(ctx context.Context, ID string, offset int, limit int) ([]*models.DimensionOption, int, error)

	// GetEditionFunc mocks the GetEdition method.
	GetEditionFunc func(ctx context.Context, ID string, editionID string, state string) (*models.EditionUpdate, error)

	// GetEditionsFunc mocks the GetEditions method.
	GetEditionsFunc func(ctx context.Context, ID string, state string, offset int, limit int, authorised bool) ([]*models.EditionUpdate, int, error)

	// GetInstanceFunc mocks the GetInstance method.
	GetInstanceFunc func(ctx context.Context, ID string, eTagSelector string) (*models.Instance, error)

	// GetInstancesFunc mocks the GetInstances method.
	GetInstancesFunc func(ctx context.Context, states []string, datasets []string, offset int, limit int) ([]*models.Instance, int, error)

	// GetLatestStaticVersionByStateFunc mocks the GetLatestStaticVersionByState method.
	GetLatestStaticVersionByStateFunc func(ctx context.Context, datasetID string, edition string, state string) (*models.Version, error)

	// GetLatestVersionStaticFunc mocks the GetLatestVersionStatic method.
	GetLatestVersionStaticFunc func(ctx context.Context, datasetID string, editionID string, state string) (*models.Version, error)

	// GetNextVersionFunc mocks the GetNextVersion method.
	GetNextVersionFunc func(ctx context.Context, datasetID string, editionID string) (int, error)

	// GetStaticEditionsByStateFunc mocks the GetStaticEditionsByState method.
	GetStaticEditionsByStateFunc func(ctx context.Context, state string, offset int, limit int) ([]*models.Version, int, error)

	// GetUniqueDimensionAndOptionsFunc mocks the GetUniqueDimensionAndOptions method.
	GetUniqueDimensionAndOptionsFunc func(ctx context.Context, ID string, dimension string) ([]*string, int, error)

	// GetUnpublishedDatasetStaticFunc mocks the GetUnpublishedDatasetStatic method.
	GetUnpublishedDatasetStaticFunc func(ctx context.Context, id string) (*models.Dataset, error)

	// GetVersionFunc mocks the GetVersion method.
	GetVersionFunc func(ctx context.Context, datasetID string, editionID string, version int, state string) (*models.Version, error)

	// GetVersionStaticFunc mocks the GetVersionStatic method.
	GetVersionStaticFunc func(ctx context.Context, datasetID string, editionID string, version int, state string) (*models.Version, error)

	// GetVersionsFunc mocks the GetVersions method.
	GetVersionsFunc func(ctx context.Context, datasetID string, editionID string, state string, offset int, limit int) ([]models.Version, int, error)

	// GetVersionsStaticFunc mocks the GetVersionsStatic method.
	GetVersionsStaticFunc func(ctx context.Context, datasetID string, edition string, state string, offset int, limit int) ([]models.Version, int, error)

	// RemoveDatasetVersionAndEditionLinksFunc mocks the RemoveDatasetVersionAndEditionLinks method.
	RemoveDatasetVersionAndEditionLinksFunc func(ctx context.Context, id string) error

	// SetInstanceIsPublishedFunc mocks the SetInstanceIsPublished method.
	SetInstanceIsPublishedFunc func(ctx context.Context, instanceID string) error

	// UnlockInstanceFunc mocks the UnlockInstance method.
	UnlockInstanceFunc func(ctx context.Context, lockID string)

	// UnlockVersionsFunc mocks the UnlockVersions method.
	UnlockVersionsFunc func(ctx context.Context, lockID string)

	// UpdateBuildHierarchyTaskStateFunc mocks the UpdateBuildHierarchyTaskState method.
	UpdateBuildHierarchyTaskStateFunc func(ctx context.Context, currentInstance *models.Instance, dimension string, state string, eTagSelector string) (string, error)

	// UpdateBuildSearchTaskStateFunc mocks the UpdateBuildSearchTaskState method.
	UpdateBuildSearchTaskStateFunc func(ctx context.Context, currentInstance *models.Instance, dimension string, state string, eTagSelector string) (string, error)

	// UpdateDatasetFunc mocks the UpdateDataset method.
	UpdateDatasetFunc func(ctx context.Context, ID string, dataset *models.Dataset, currentState string) error

	// UpdateDatasetWithAssociationFunc mocks the UpdateDatasetWithAssociation method.
	UpdateDatasetWithAssociationFunc func(ctx context.Context, ID string, state string, version *models.Version) error

	// UpdateDimensionsNodeIDAndOrderFunc mocks the UpdateDimensionsNodeIDAndOrder method.
	UpdateDimensionsNodeIDAndOrderFunc func(ctx context.Context, updates []*models.DimensionOption) error

	// UpdateETagForOptionsFunc mocks the UpdateETagForOptions method.
	UpdateETagForOptionsFunc func(ctx context.Context, currentInstance *models.Instance, upserts []*models.CachedDimensionOption, updates []*models.DimensionOption, eTagSelector string) (string, error)

	// UpdateImportObservationsTaskStateFunc mocks the UpdateImportObservationsTaskState method.
	UpdateImportObservationsTaskStateFunc func(ctx context.Context, currentInstance *models.Instance, state string, eTagSelector string) (string, error)

	// UpdateInstanceFunc mocks the UpdateInstance method.
	UpdateInstanceFunc func(ctx context.Context, currentInstance *models.Instance, updatedInstance *models.Instance, eTagSelector string) (string, error)

	// UpdateMetadataFunc mocks the UpdateMetadata method.
	UpdateMetadataFunc func(ctx context.Context, datasetID string, versionID string, versionEtag string, updatedDataset *models.Dataset, updatedVersion *models.Version) error

	// UpdateObservationInsertedFunc mocks the UpdateObservationInserted method.
	UpdateObservationInsertedFunc func(ctx context.Context, currentInstance *models.Instance, observationInserted int64, eTagSelector string) (string, error)

	// UpdateVersionFunc mocks the UpdateVersion method.
	UpdateVersionFunc func(ctx context.Context, currentVersion *models.Version, version *models.Version, eTagSelector string) (string, error)

	// UpdateVersionStaticFunc mocks the UpdateVersionStatic method.
	UpdateVersionStaticFunc func(ctx context.Context, currentVersion *models.Version, versionUpdate *models.Version, eTagSelector string) (string, error)

	// UpsertContactFunc mocks the UpsertContact method.
	UpsertContactFunc func(ctx context.Context, ID string, update interface{}) error

	// UpsertDatasetFunc mocks the UpsertDataset method.
	UpsertDatasetFunc func(ctx context.Context, ID string, datasetDoc *models.DatasetUpdate) error

	// UpsertDimensionsToInstanceFunc mocks the UpsertDimensionsToInstance method.
	UpsertDimensionsToInstanceFunc func(ctx context.Context, dimensions []*models.CachedDimensionOption) error

	// UpsertEditionFunc mocks the UpsertEdition method.
	UpsertEditionFunc func(ctx context.Context, datasetID string, edition string, editionDoc *models.EditionUpdate) error

	// UpsertVersionFunc mocks the UpsertVersion method.
	UpsertVersionFunc func(ctx context.Context, ID string, versionDoc *models.Version) error

	// UpsertVersionStaticFunc mocks the UpsertVersionStatic method.
	UpsertVersionStaticFunc func(ctx context.Context, ID string, versionDoc *models.Version) error

	// calls tracks calls to the methods.
	calls struct {
		// AcquireInstanceLock holds details about calls to the AcquireInstanceLock method.
		AcquireInstanceLock []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// InstanceID is the instanceID argument value.
			InstanceID string
		}
		// AcquireVersionsLock holds details about calls to the AcquireVersionsLock method.
		AcquireVersionsLock []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// VersionID is the versionID argument value.
			VersionID string
		}
		// AddEventToInstance holds details about calls to the AddEventToInstance method.
		AddEventToInstance []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// CurrentInstance is the currentInstance argument value.
			CurrentInstance *models.Instance
			// Event is the event argument value.
			Event *models.Event
			// ETagSelector is the eTagSelector argument value.
			ETagSelector string
		}
		// AddInstance holds details about calls to the AddInstance method.
		AddInstance []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Instance is the instance argument value.
			Instance *models.Instance
		}
		// AddVersionDetailsToInstance holds details about calls to the AddVersionDetailsToInstance method.
		AddVersionDetailsToInstance []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// InstanceID is the instanceID argument value.
			InstanceID string
			// DatasetID is the datasetID argument value.
			DatasetID string
			// Edition is the edition argument value.
			Edition string
			// Version is the version argument value.
			Version int
		}
		// AddVersionStatic holds details about calls to the AddVersionStatic method.
		AddVersionStatic []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Version is the version argument value.
			Version *models.Version
		}
		// CheckDatasetExists holds details about calls to the CheckDatasetExists method.
		CheckDatasetExists []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the ID argument value.
			ID string
			// State is the state argument value.
			State string
		}
		// CheckDatasetTitleExist holds details about calls to the CheckDatasetTitleExist method.
		CheckDatasetTitleExist []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Title is the title argument value.
			Title string
		}
		// CheckEditionExists holds details about calls to the CheckEditionExists method.
		CheckEditionExists []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the ID argument value.
			ID string
			// EditionID is the editionID argument value.
			EditionID string
			// State is the state argument value.
			State string
		}
		// CheckEditionExistsStatic holds details about calls to the CheckEditionExistsStatic method.
		CheckEditionExistsStatic []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID string
			// EditionID is the editionID argument value.
			EditionID string
			// State is the state argument value.
			State string
		}
		// DeleteDataset holds details about calls to the DeleteDataset method.
		DeleteDataset []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the ID argument value.
			ID string
		}
		// DeleteEdition holds details about calls to the DeleteEdition method.
		DeleteEdition []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the ID argument value.
			ID string
		}
		// GetAllStaticVersions holds details about calls to the GetAllStaticVersions method.
		GetAllStaticVersions []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the ID argument value.
			ID string
			// State is the state argument value.
			State string
			// Offset is the offset argument value.
			Offset int
			// Limit is the limit argument value.
			Limit int
		}
		// GetDataset holds details about calls to the GetDataset method.
		GetDataset []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the ID argument value.
			ID string
		}
		// GetDatasetType holds details about calls to the GetDatasetType method.
		GetDatasetType []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// DatasetID is the datasetID argument value.
			DatasetID string
			// Authorised is the authorised argument value.
			Authorised bool
		}
		// GetDatasets holds details about calls to the GetDatasets method.
		GetDatasets []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Offset is the offset argument value.
			Offset int
			// Limit is the limit argument value.
			Limit int
			// Authorised is the authorised argument value.
			Authorised bool
		}
		// GetDatasetsByQueryParams holds details about calls to the GetDatasetsByQueryParams method.
		GetDatasetsByQueryParams []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the ID argument value.
			ID string
			// DatasetType is the datasetType argument value.
			DatasetType string
			// Offset is the offset argument value.
			Offset int
			// Limit is the limit argument value.
			Limit int
			// Authorised is the authorised argument value.
			Authorised bool
		}
		// GetDimensionOptions holds details about calls to the GetDimensionOptions method.
		GetDimensionOptions []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Version is the version argument value.
			Version *models.Version
			// Dimension is the dimension argument value.
			Dimension string
			// Offset is the offset argument value.
			Offset int
			// Limit is the limit argument value.
			Limit int
		}
		// GetDimensionOptionsFromIDs holds details about calls to the GetDimensionOptionsFromIDs method.
		GetDimensionOptionsFromIDs []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Version is the version argument value.
			Version *models.Version
			// Dimension is the dimension argument value.
			Dimension string
			// Ids is the ids argument value.
			Ids []string
		}
		// GetDimensions holds details about calls to the GetDimensions method.
		GetDimensions []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// VersionID is the versionID argument value.
			VersionID string
		}
		// GetDimensionsFromInstance holds details about calls to the GetDimensionsFromInstance method.
		GetDimensionsFromInstance []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the ID argument value.
			ID string
			// Offset is the offset argument value.
			Offset int
			// Limit is the limit argument value.
			Limit int
		}
		// GetEdition holds details about calls to the GetEdition method.
		GetEdition []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the ID argument value.
			ID string
			// EditionID is the editionID argument value.
			EditionID string
			// State is the state argument value.
			State string
		}
		// GetEditions holds details about calls to the GetEditions method.
		GetEditions []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the ID argument value.
			ID string
			// State is the state argument value.
			State string
			// Offset is the offset argument value.
			Offset int
			// Limit is the limit argument value.
			Limit int
			// Authorised is the authorised argument value.
			Authorised bool
		}
		// GetInstance holds details about calls to the GetInstance method.
		GetInstance []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the ID argument value.
			ID string
			// ETagSelector is the eTagSelector argument value.
			ETagSelector string
		}
		// GetInstances holds details about calls to the GetInstances method.
		GetInstances []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// States is the states argument value.
			States []string
			// Datasets is the datasets argument value.
			Datasets []string
			// Offset is the offset argument value.
			Offset int
			// Limit is the limit argument value.
			Limit int
		}
		// GetLatestStaticVersionByState holds details about calls to the GetLatestStaticVersionByState method.
		GetLatestStaticVersionByState []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// DatasetID is the datasetID argument value.
			DatasetID string
			// Edition is the edition argument value.
			Edition string
			// State is the state argument value.
			State string
		}
		// GetLatestVersionStatic holds details about calls to the GetLatestVersionStatic method.
		GetLatestVersionStatic []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// DatasetID is the datasetID argument value.
			DatasetID string
			// EditionID is the editionID argument value.
			EditionID string
			// State is the state argument value.
			State string
		}
		// GetNextVersion holds details about calls to the GetNextVersion method.
		GetNextVersion []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// DatasetID is the datasetID argument value.
			DatasetID string
			// EditionID is the editionID argument value.
			EditionID string
		}
		// GetStaticEditionsByState holds details about calls to the GetStaticEditionsByState method.
		GetStaticEditionsByState []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// State is the state argument value.
			State string
			// Offset is the offset argument value.
			Offset int
			// Limit is the limit argument value.
			Limit int
		}
		// GetUniqueDimensionAndOptions holds details about calls to the GetUniqueDimensionAndOptions method.
		GetUniqueDimensionAndOptions []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the ID argument value.
			ID string
			// Dimension is the dimension argument value.
			Dimension string
		}
		// GetUnpublishedDatasetStatic holds details about calls to the GetUnpublishedDatasetStatic method.
		GetUnpublishedDatasetStatic []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID string
		}
		// GetVersion holds details about calls to the GetVersion method.
		GetVersion []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// DatasetID is the datasetID argument value.
			DatasetID string
			// EditionID is the editionID argument value.
			EditionID string
			// Version is the version argument value.
			Version int
			// State is the state argument value.
			State string
		}
		// GetVersionStatic holds details about calls to the GetVersionStatic method.
		GetVersionStatic []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// DatasetID is the datasetID argument value.
			DatasetID string
			// EditionID is the editionID argument value.
			EditionID string
			// Version is the version argument value.
			Version int
			// State is the state argument value.
			State string
		}
		// GetVersions holds details about calls to the GetVersions method.
		GetVersions []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// DatasetID is the datasetID argument value.
			DatasetID string
			// EditionID is the editionID argument value.
			EditionID string
			// State is the state argument value.
			State string
			// Offset is the offset argument value.
			Offset int
			// Limit is the limit argument value.
			Limit int
		}
		// GetVersionsStatic holds details about calls to the GetVersionsStatic method.
		GetVersionsStatic []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// DatasetID is the datasetID argument value.
			DatasetID string
			// Edition is the edition argument value.
			Edition string
			// State is the state argument value.
			State string
			// Offset is the offset argument value.
			Offset int
			// Limit is the limit argument value.
			Limit int
		}
		// RemoveDatasetVersionAndEditionLinks holds details about calls to the RemoveDatasetVersionAndEditionLinks method.
		RemoveDatasetVersionAndEditionLinks []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID string
		}
		// SetInstanceIsPublished holds details about calls to the SetInstanceIsPublished method.
		SetInstanceIsPublished []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// InstanceID is the instanceID argument value.
			InstanceID string
		}
		// UnlockInstance holds details about calls to the UnlockInstance method.
		UnlockInstance []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// LockID is the lockID argument value.
			LockID string
		}
		// UnlockVersions holds details about calls to the UnlockVersions method.
		UnlockVersions []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// LockID is the lockID argument value.
			LockID string
		}
		// UpdateBuildHierarchyTaskState holds details about calls to the UpdateBuildHierarchyTaskState method.
		UpdateBuildHierarchyTaskState []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// CurrentInstance is the currentInstance argument value.
			CurrentInstance *models.Instance
			// Dimension is the dimension argument value.
			Dimension string
			// State is the state argument value.
			State string
			// ETagSelector is the eTagSelector argument value.
			ETagSelector string
		}
		// UpdateBuildSearchTaskState holds details about calls to the UpdateBuildSearchTaskState method.
		UpdateBuildSearchTaskState []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// CurrentInstance is the currentInstance argument value.
			CurrentInstance *models.Instance
			// Dimension is the dimension argument value.
			Dimension string
			// State is the state argument value.
			State string
			// ETagSelector is the eTagSelector argument value.
			ETagSelector string
		}
		// UpdateDataset holds details about calls to the UpdateDataset method.
		UpdateDataset []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the ID argument value.
			ID string
			// Dataset is the dataset argument value.
			Dataset *models.Dataset
			// CurrentState is the currentState argument value.
			CurrentState string
		}
		// UpdateDatasetWithAssociation holds details about calls to the UpdateDatasetWithAssociation method.
		UpdateDatasetWithAssociation []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the ID argument value.
			ID string
			// State is the state argument value.
			State string
			// Version is the version argument value.
			Version *models.Version
		}
		// UpdateDimensionsNodeIDAndOrder holds details about calls to the UpdateDimensionsNodeIDAndOrder method.
		UpdateDimensionsNodeIDAndOrder []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Updates is the updates argument value.
			Updates []*models.DimensionOption
		}
		// UpdateETagForOptions holds details about calls to the UpdateETagForOptions method.
		UpdateETagForOptions []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// CurrentInstance is the currentInstance argument value.
			CurrentInstance *models.Instance
			// Upserts is the upserts argument value.
			Upserts []*models.CachedDimensionOption
			// Updates is the updates argument value.
			Updates []*models.DimensionOption
			// ETagSelector is the eTagSelector argument value.
			ETagSelector string
		}
		// UpdateImportObservationsTaskState holds details about calls to the UpdateImportObservationsTaskState method.
		UpdateImportObservationsTaskState []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// CurrentInstance is the currentInstance argument value.
			CurrentInstance *models.Instance
			// State is the state argument value.
			State string
			// ETagSelector is the eTagSelector argument value.
			ETagSelector string
		}
		// UpdateInstance holds details about calls to the UpdateInstance method.
		UpdateInstance []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// CurrentInstance is the currentInstance argument value.
			CurrentInstance *models.Instance
			// UpdatedInstance is the updatedInstance argument value.
			UpdatedInstance *models.Instance
			// ETagSelector is the eTagSelector argument value.
			ETagSelector string
		}
		// UpdateMetadata holds details about calls to the UpdateMetadata method.
		UpdateMetadata []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// DatasetID is the datasetID argument value.
			DatasetID string
			// VersionID is the versionID argument value.
			VersionID string
			// VersionEtag is the versionEtag argument value.
			VersionEtag string
			// UpdatedDataset is the updatedDataset argument value.
			UpdatedDataset *models.Dataset
			// UpdatedVersion is the updatedVersion argument value.
			UpdatedVersion *models.Version
		}
		// UpdateObservationInserted holds details about calls to the UpdateObservationInserted method.
		UpdateObservationInserted []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// CurrentInstance is the currentInstance argument value.
			CurrentInstance *models.Instance
			// ObservationInserted is the observationInserted argument value.
			ObservationInserted int64
			// ETagSelector is the eTagSelector argument value.
			ETagSelector string
		}
		// UpdateVersion holds details about calls to the UpdateVersion method.
		UpdateVersion []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// CurrentVersion is the currentVersion argument value.
			CurrentVersion *models.Version
			// Version is the version argument value.
			Version *models.Version
			// ETagSelector is the eTagSelector argument value.
			ETagSelector string
		}
		// UpdateVersionStatic holds details about calls to the UpdateVersionStatic method.
		UpdateVersionStatic []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// CurrentVersion is the currentVersion argument value.
			CurrentVersion *models.Version
			// VersionUpdate is the versionUpdate argument value.
			VersionUpdate *models.Version
			// ETagSelector is the eTagSelector argument value.
			ETagSelector string
		}
		// UpsertContact holds details about calls to the UpsertContact method.
		UpsertContact []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the ID argument value.
			ID string
			// Update is the update argument value.
			Update interface{}
		}
		// UpsertDataset holds details about calls to the UpsertDataset method.
		UpsertDataset []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the ID argument value.
			ID string
			// DatasetDoc is the datasetDoc argument value.
			DatasetDoc *models.DatasetUpdate
		}
		// UpsertDimensionsToInstance holds details about calls to the UpsertDimensionsToInstance method.
		UpsertDimensionsToInstance []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Dimensions is the dimensions argument value.
			Dimensions []*models.CachedDimensionOption
		}
		// UpsertEdition holds details about calls to the UpsertEdition method.
		UpsertEdition []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// DatasetID is the datasetID argument value.
			DatasetID string
			// Edition is the edition argument value.
			Edition string
			// EditionDoc is the editionDoc argument value.
			EditionDoc *models.EditionUpdate
		}
		// UpsertVersion holds details about calls to the UpsertVersion method.
		UpsertVersion []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the ID argument value.
			ID string
			// VersionDoc is the versionDoc argument value.
			VersionDoc *models.Version
		}
		// UpsertVersionStatic holds details about calls to the UpsertVersionStatic method.
		UpsertVersionStatic []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the ID argument value.
			ID string
			// VersionDoc is the versionDoc argument value.
			VersionDoc *models.Version
		}
	}
	lockAcquireInstanceLock                 sync.RWMutex
	lockAcquireVersionsLock                 sync.RWMutex
	lockAddEventToInstance                  sync.RWMutex
	lockAddInstance                         sync.RWMutex
	lockAddVersionDetailsToInstance         sync.RWMutex
	lockAddVersionStatic                    sync.RWMutex
	lockCheckDatasetExists                  sync.RWMutex
	lockCheckDatasetTitleExist              sync.RWMutex
	lockCheckEditionExists                  sync.RWMutex
	lockCheckEditionExistsStatic            sync.RWMutex
	lockDeleteDataset                       sync.RWMutex
	lockDeleteEdition                       sync.RWMutex
	lockGetAllStaticVersions                sync.RWMutex
	lockGetDataset                          sync.RWMutex
	lockGetDatasetType                      sync.RWMutex
	lockGetDatasets                         sync.RWMutex
	lockGetDatasetsByQueryParams            sync.RWMutex
	lockGetDimensionOptions                 sync.RWMutex
	lockGetDimensionOptionsFromIDs          sync.RWMutex
	lockGetDimensions                       sync.RWMutex
	lockGetDimensionsFromInstance           sync.RWMutex
	lockGetEdition                          sync.RWMutex
	lockGetEditions                         sync.RWMutex
	lockGetInstance                         sync.RWMutex
	lockGetInstances                        sync.RWMutex
	lockGetLatestStaticVersionByState       sync.RWMutex
	lockGetLatestVersionStatic              sync.RWMutex
	lockGetNextVersion                      sync.RWMutex
	lockGetStaticEditionsByState            sync.RWMutex
	lockGetUniqueDimensionAndOptions        sync.RWMutex
	lockGetUnpublishedDatasetStatic         sync.RWMutex
	lockGetVersion                          sync.RWMutex
	lockGetVersionStatic                    sync.RWMutex
	lockGetVersions                         sync.RWMutex
	lockGetVersionsStatic                   sync.RWMutex
	lockRemoveDatasetVersionAndEditionLinks sync.RWMutex
	lockSetInstanceIsPublished              sync.RWMutex
	lockUnlockInstance                      sync.RWMutex
	lockUnlockVersions                      sync.RWMutex
	lockUpdateBuildHierarchyTaskState       sync.RWMutex
	lockUpdateBuildSearchTaskState          sync.RWMutex
	lockUpdateDataset                       sync.RWMutex
	lockUpdateDatasetWithAssociation        sync.RWMutex
	lockUpdateDimensionsNodeIDAndOrder      sync.RWMutex
	lockUpdateETagForOptions                sync.RWMutex
	lockUpdateImportObservationsTaskState   sync.RWMutex
	lockUpdateInstance                      sync.RWMutex
	lockUpdateMetadata                      sync.RWMutex
	lockUpdateObservationInserted           sync.RWMutex
	lockUpdateVersion                       sync.RWMutex
	lockUpdateVersionStatic                 sync.RWMutex
	lockUpsertContact                       sync.RWMutex
	lockUpsertDataset                       sync.RWMutex
	lockUpsertDimensionsToInstance          sync.RWMutex
	lockUpsertEdition                       sync.RWMutex
	lockUpsertVersion                       sync.RWMutex
	lockUpsertVersionStatic                 sync.RWMutex
}

// AcquireInstanceLock calls AcquireInstanceLockFunc.
func (mock *StorerMock) AcquireInstanceLock(ctx context.Context, instanceID string) (string, error) {
	if mock.AcquireInstanceLockFunc == nil {
		panic("StorerMock.AcquireInstanceLockFunc: method is nil but Storer.AcquireInstanceLock was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		InstanceID string
	}{
		Ctx:        ctx,
		InstanceID: instanceID,
	}
	mock.lockAcquireInstanceLock.Lock()
	mock.calls.AcquireInstanceLock = append(mock.calls.AcquireInstanceLock, callInfo)
	mock.lockAcquireInstanceLock.Unlock()
	return mock.AcquireInstanceLockFunc(ctx, instanceID)
}

// AcquireInstanceLockCalls gets all the calls that were made to AcquireInstanceLock.
// Check the length with:
//
//	len(mockedStorer.AcquireInstanceLockCalls())
func (mock *StorerMock) AcquireInstanceLockCalls() []struct {
	Ctx        context.Context
	InstanceID string
} {
	var calls []struct {
		Ctx        context.Context
		InstanceID string
	}
	mock.lockAcquireInstanceLock.RLock()
	calls = mock.calls.AcquireInstanceLock
	mock.lockAcquireInstanceLock.RUnlock()
	return calls
}

// AcquireVersionsLock calls AcquireVersionsLockFunc.
func (mock *StorerMock) AcquireVersionsLock(ctx context.Context, versionID string) (string, error) {
	if mock.AcquireVersionsLockFunc == nil {
		panic("StorerMock.AcquireVersionsLockFunc: method is nil but Storer.AcquireVersionsLock was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		VersionID string
	}{
		Ctx:       ctx,
		VersionID: versionID,
	}
	mock.lockAcquireVersionsLock.Lock()
	mock.calls.AcquireVersionsLock = append(mock.calls.AcquireVersionsLock, callInfo)
	mock.lockAcquireVersionsLock.Unlock()
	return mock.AcquireVersionsLockFunc(ctx, versionID)
}

// AcquireVersionsLockCalls gets all the calls that were made to AcquireVersionsLock.
// Check the length with:
//
//	len(mockedStorer.AcquireVersionsLockCalls())
func (mock *StorerMock) AcquireVersionsLockCalls() []struct {
	Ctx       context.Context
	VersionID string
} {
	var calls []struct {
		Ctx       context.Context
		VersionID string
	}
	mock.lockAcquireVersionsLock.RLock()
	calls = mock.calls.AcquireVersionsLock
	mock.lockAcquireVersionsLock.RUnlock()
	return calls
}

// AddEventToInstance calls AddEventToInstanceFunc.
func (mock *StorerMock) AddEventToInstance(ctx context.Context, currentInstance *models.Instance, event *models.Event, eTagSelector string) (string, error) {
	if mock.AddEventToInstanceFunc == nil {
		panic("StorerMock.AddEventToInstanceFunc: method is nil but Storer.AddEventToInstance was just called")
	}
	callInfo := struct {
		Ctx             context.Context
		CurrentInstance *models.Instance
		Event           *models.Event
		ETagSelector    string
	}{
		Ctx:             ctx,
		CurrentInstance: currentInstance,
		Event:           event,
		ETagSelector:    eTagSelector,
	}
	mock.lockAddEventToInstance.Lock()
	mock.calls.AddEventToInstance = append(mock.calls.AddEventToInstance, callInfo)
	mock.lockAddEventToInstance.Unlock()
	return mock.AddEventToInstanceFunc(ctx, currentInstance, event, eTagSelector)
}

// AddEventToInstanceCalls gets all the calls that were made to AddEventToInstance.
// Check the length with:
//
//	len(mockedStorer.AddEventToInstanceCalls())
func (mock *StorerMock) AddEventToInstanceCalls() []struct {
	Ctx             context.Context
	CurrentInstance *models.Instance
	Event           *models.Event
	ETagSelector    string
} {
	var calls []struct {
		Ctx             context.Context
		CurrentInstance *models.Instance
		Event           *models.Event
		ETagSelector    string
	}
	mock.lockAddEventToInstance.RLock()
	calls = mock.calls.AddEventToInstance
	mock.lockAddEventToInstance.RUnlock()
	return calls
}

// AddInstance calls AddInstanceFunc.
func (mock *StorerMock) AddInstance(ctx context.Context, instance *models.Instance) (*models.Instance, error) {
	if mock.AddInstanceFunc == nil {
		panic("StorerMock.AddInstanceFunc: method is nil but Storer.AddInstance was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		Instance *models.Instance
	}{
		Ctx:      ctx,
		Instance: instance,
	}
	mock.lockAddInstance.Lock()
	mock.calls.AddInstance = append(mock.calls.AddInstance, callInfo)
	mock.lockAddInstance.Unlock()
	return mock.AddInstanceFunc(ctx, instance)
}

// AddInstanceCalls gets all the calls that were made to AddInstance.
// Check the length with:
//
//	len(mockedStorer.AddInstanceCalls())
func (mock *StorerMock) AddInstanceCalls() []struct {
	Ctx      context.Context
	Instance *models.Instance
} {
	var calls []struct {
		Ctx      context.Context
		Instance *models.Instance
	}
	mock.lockAddInstance.RLock()
	calls = mock.calls.AddInstance
	mock.lockAddInstance.RUnlock()
	return calls
}

// AddVersionDetailsToInstance calls AddVersionDetailsToInstanceFunc.
func (mock *StorerMock) AddVersionDetailsToInstance(ctx context.Context, instanceID string, datasetID string, edition string, version int) error {
	if mock.AddVersionDetailsToInstanceFunc == nil {
		panic("StorerMock.AddVersionDetailsToInstanceFunc: method is nil but Storer.AddVersionDetailsToInstance was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		InstanceID string
		DatasetID  string
		Edition    string
		Version    int
	}{
		Ctx:        ctx,
		InstanceID: instanceID,
		DatasetID:  datasetID,
		Edition:    edition,
		Version:    version,
	}
	mock.lockAddVersionDetailsToInstance.Lock()
	mock.calls.AddVersionDetailsToInstance = append(mock.calls.AddVersionDetailsToInstance, callInfo)
	mock.lockAddVersionDetailsToInstance.Unlock()
	return mock.AddVersionDetailsToInstanceFunc(ctx, instanceID, datasetID, edition, version)
}

// AddVersionDetailsToInstanceCalls gets all the calls that were made to AddVersionDetailsToInstance.
// Check the length with:
//
//	len(mockedStorer.AddVersionDetailsToInstanceCalls())
func (mock *StorerMock) AddVersionDetailsToInstanceCalls() []struct {
	Ctx        context.Context
	InstanceID string
	DatasetID  string
	Edition    string
	Version    int
} {
	var calls []struct {
		Ctx        context.Context
		InstanceID string
		DatasetID  string
		Edition    string
		Version    int
	}
	mock.lockAddVersionDetailsToInstance.RLock()
	calls = mock.calls.AddVersionDetailsToInstance
	mock.lockAddVersionDetailsToInstance.RUnlock()
	return calls
}

// AddVersionStatic calls AddVersionStaticFunc.
func (mock *StorerMock) AddVersionStatic(ctx context.Context, version *models.Version) (*models.Version, error) {
	if mock.AddVersionStaticFunc == nil {
		panic("StorerMock.AddVersionStaticFunc: method is nil but Storer.AddVersionStatic was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Version *models.Version
	}{
		Ctx:     ctx,
		Version: version,
	}
	mock.lockAddVersionStatic.Lock()
	mock.calls.AddVersionStatic = append(mock.calls.AddVersionStatic, callInfo)
	mock.lockAddVersionStatic.Unlock()
	return mock.AddVersionStaticFunc(ctx, version)
}

// AddVersionStaticCalls gets all the calls that were made to AddVersionStatic.
// Check the length with:
//
//	len(mockedStorer.AddVersionStaticCalls())
func (mock *StorerMock) AddVersionStaticCalls() []struct {
	Ctx     context.Context
	Version *models.Version
} {
	var calls []struct {
		Ctx     context.Context
		Version *models.Version
	}
	mock.lockAddVersionStatic.RLock()
	calls = mock.calls.AddVersionStatic
	mock.lockAddVersionStatic.RUnlock()
	return calls
}

// CheckDatasetExists calls CheckDatasetExistsFunc.
func (mock *StorerMock) CheckDatasetExists(ctx context.Context, ID string, state string) error {
	if mock.CheckDatasetExistsFunc == nil {
		panic("StorerMock.CheckDatasetExistsFunc: method is nil but Storer.CheckDatasetExists was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		ID    string
		State string
	}{
		Ctx:   ctx,
		ID:    ID,
		State: state,
	}
	mock.lockCheckDatasetExists.Lock()
	mock.calls.CheckDatasetExists = append(mock.calls.CheckDatasetExists, callInfo)
	mock.lockCheckDatasetExists.Unlock()
	return mock.CheckDatasetExistsFunc(ctx, ID, state)
}

// CheckDatasetExistsCalls gets all the calls that were made to CheckDatasetExists.
// Check the length with:
//
//	len(mockedStorer.CheckDatasetExistsCalls())
func (mock *StorerMock) CheckDatasetExistsCalls() []struct {
	Ctx   context.Context
	ID    string
	State string
} {
	var calls []struct {
		Ctx   context.Context
		ID    string
		State string
	}
	mock.lockCheckDatasetExists.RLock()
	calls = mock.calls.CheckDatasetExists
	mock.lockCheckDatasetExists.RUnlock()
	return calls
}

// CheckDatasetTitleExist calls CheckDatasetTitleExistFunc.
func (mock *StorerMock) CheckDatasetTitleExist(ctx context.Context, title string) (bool, error) {
	if mock.CheckDatasetTitleExistFunc == nil {
		panic("StorerMock.CheckDatasetTitleExistFunc: method is nil but Storer.CheckDatasetTitleExist was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Title string
	}{
		Ctx:   ctx,
		Title: title,
	}
	mock.lockCheckDatasetTitleExist.Lock()
	mock.calls.CheckDatasetTitleExist = append(mock.calls.CheckDatasetTitleExist, callInfo)
	mock.lockCheckDatasetTitleExist.Unlock()
	return mock.CheckDatasetTitleExistFunc(ctx, title)
}

// CheckDatasetTitleExistCalls gets all the calls that were made to CheckDatasetTitleExist.
// Check the length with:
//
//	len(mockedStorer.CheckDatasetTitleExistCalls())
func (mock *StorerMock) CheckDatasetTitleExistCalls() []struct {
	Ctx   context.Context
	Title string
} {
	var calls []struct {
		Ctx   context.Context
		Title string
	}
	mock.lockCheckDatasetTitleExist.RLock()
	calls = mock.calls.CheckDatasetTitleExist
	mock.lockCheckDatasetTitleExist.RUnlock()
	return calls
}

// CheckEditionExists calls CheckEditionExistsFunc.
func (mock *StorerMock) CheckEditionExists(ctx context.Context, ID string, editionID string, state string) error {
	if mock.CheckEditionExistsFunc == nil {
		panic("StorerMock.CheckEditionExistsFunc: method is nil but Storer.CheckEditionExists was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		ID        string
		EditionID string
		State     string
	}{
		Ctx:       ctx,
		ID:        ID,
		EditionID: editionID,
		State:     state,
	}
	mock.lockCheckEditionExists.Lock()
	mock.calls.CheckEditionExists = append(mock.calls.CheckEditionExists, callInfo)
	mock.lockCheckEditionExists.Unlock()
	return mock.CheckEditionExistsFunc(ctx, ID, editionID, state)
}

// CheckEditionExistsCalls gets all the calls that were made to CheckEditionExists.
// Check the length with:
//
//	len(mockedStorer.CheckEditionExistsCalls())
func (mock *StorerMock) CheckEditionExistsCalls() []struct {
	Ctx       context.Context
	ID        string
	EditionID string
	State     string
} {
	var calls []struct {
		Ctx       context.Context
		ID        string
		EditionID string
		State     string
	}
	mock.lockCheckEditionExists.RLock()
	calls = mock.calls.CheckEditionExists
	mock.lockCheckEditionExists.RUnlock()
	return calls
}

// CheckEditionExistsStatic calls CheckEditionExistsStaticFunc.
func (mock *StorerMock) CheckEditionExistsStatic(ctx context.Context, id string, editionID string, state string) error {
	if mock.CheckEditionExistsStaticFunc == nil {
		panic("StorerMock.CheckEditionExistsStaticFunc: method is nil but Storer.CheckEditionExistsStatic was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		ID        string
		EditionID string
		State     string
	}{
		Ctx:       ctx,
		ID:        id,
		EditionID: editionID,
		State:     state,
	}
	mock.lockCheckEditionExistsStatic.Lock()
	mock.calls.CheckEditionExistsStatic = append(mock.calls.CheckEditionExistsStatic, callInfo)
	mock.lockCheckEditionExistsStatic.Unlock()
	return mock.CheckEditionExistsStaticFunc(ctx, id, editionID, state)
}

// CheckEditionExistsStaticCalls gets all the calls that were made to CheckEditionExistsStatic.
// Check the length with:
//
//	len(mockedStorer.CheckEditionExistsStaticCalls())
func (mock *StorerMock) CheckEditionExistsStaticCalls() []struct {
	Ctx       context.Context
	ID        string
	EditionID string
	State     string
} {
	var calls []struct {
		Ctx       context.Context
		ID        string
		EditionID string
		State     string
	}
	mock.lockCheckEditionExistsStatic.RLock()
	calls = mock.calls.CheckEditionExistsStatic
	mock.lockCheckEditionExistsStatic.RUnlock()
	return calls
}

// DeleteDataset calls DeleteDatasetFunc.
func (mock *StorerMock) DeleteDataset(ctx context.Context, ID string) error {
	if mock.DeleteDatasetFunc == nil {
		panic("StorerMock.DeleteDatasetFunc: method is nil but Storer.DeleteDataset was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  string
	}{
		Ctx: ctx,
		ID:  ID,
	}
	mock.lockDeleteDataset.Lock()
	mock.calls.DeleteDataset = append(mock.calls.DeleteDataset, callInfo)
	mock.lockDeleteDataset.Unlock()
	return mock.DeleteDatasetFunc(ctx, ID)
}

// DeleteDatasetCalls gets all the calls that were made to DeleteDataset.
// Check the length with:
//
//	len(mockedStorer.DeleteDatasetCalls())
func (mock *StorerMock) DeleteDatasetCalls() []struct {
	Ctx context.Context
	ID  string
} {
	var calls []struct {
		Ctx context.Context
		ID  string
	}
	mock.lockDeleteDataset.RLock()
	calls = mock.calls.DeleteDataset
	mock.lockDeleteDataset.RUnlock()
	return calls
}

// DeleteEdition calls DeleteEditionFunc.
func (mock *StorerMock) DeleteEdition(ctx context.Context, ID string) error {
	if mock.DeleteEditionFunc == nil {
		panic("StorerMock.DeleteEditionFunc: method is nil but Storer.DeleteEdition was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  string
	}{
		Ctx: ctx,
		ID:  ID,
	}
	mock.lockDeleteEdition.Lock()
	mock.calls.DeleteEdition = append(mock.calls.DeleteEdition, callInfo)
	mock.lockDeleteEdition.Unlock()
	return mock.DeleteEditionFunc(ctx, ID)
}

// DeleteEditionCalls gets all the calls that were made to DeleteEdition.
// Check the length with:
//
//	len(mockedStorer.DeleteEditionCalls())
func (mock *StorerMock) DeleteEditionCalls() []struct {
	Ctx context.Context
	ID  string
} {
	var calls []struct {
		Ctx context.Context
		ID  string
	}
	mock.lockDeleteEdition.RLock()
	calls = mock.calls.DeleteEdition
	mock.lockDeleteEdition.RUnlock()
	return calls
}

// GetAllStaticVersions calls GetAllStaticVersionsFunc.
func (mock *StorerMock) GetAllStaticVersions(ctx context.Context, ID string, state string, offset int, limit int) ([]*models.Version, int, error) {
	if mock.GetAllStaticVersionsFunc == nil {
		panic("StorerMock.GetAllStaticVersionsFunc: method is nil but Storer.GetAllStaticVersions was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		ID     string
		State  string
		Offset int
		Limit  int
	}{
		Ctx:    ctx,
		ID:     ID,
		State:  state,
		Offset: offset,
		Limit:  limit,
	}
	mock.lockGetAllStaticVersions.Lock()
	mock.calls.GetAllStaticVersions = append(mock.calls.GetAllStaticVersions, callInfo)
	mock.lockGetAllStaticVersions.Unlock()
	return mock.GetAllStaticVersionsFunc(ctx, ID, state, offset, limit)
}

// GetAllStaticVersionsCalls gets all the calls that were made to GetAllStaticVersions.
// Check the length with:
//
//	len(mockedStorer.GetAllStaticVersionsCalls())
func (mock *StorerMock) GetAllStaticVersionsCalls() []struct {
	Ctx    context.Context
	ID     string
	State  string
	Offset int
	Limit  int
} {
	var calls []struct {
		Ctx    context.Context
		ID     string
		State  string
		Offset int
		Limit  int
	}
	mock.lockGetAllStaticVersions.RLock()
	calls = mock.calls.GetAllStaticVersions
	mock.lockGetAllStaticVersions.RUnlock()
	return calls
}

// GetDataset calls GetDatasetFunc.
func (mock *StorerMock) GetDataset(ctx context.Context, ID string) (*models.DatasetUpdate, error) {
	if mock.GetDatasetFunc == nil {
		panic("StorerMock.GetDatasetFunc: method is nil but Storer.GetDataset was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  string
	}{
		Ctx: ctx,
		ID:  ID,
	}
	mock.lockGetDataset.Lock()
	mock.calls.GetDataset = append(mock.calls.GetDataset, callInfo)
	mock.lockGetDataset.Unlock()
	return mock.GetDatasetFunc(ctx, ID)
}

// GetDatasetCalls gets all the calls that were made to GetDataset.
// Check the length with:
//
//	len(mockedStorer.GetDatasetCalls())
func (mock *StorerMock) GetDatasetCalls() []struct {
	Ctx context.Context
	ID  string
} {
	var calls []struct {
		Ctx context.Context
		ID  string
	}
	mock.lockGetDataset.RLock()
	calls = mock.calls.GetDataset
	mock.lockGetDataset.RUnlock()
	return calls
}

// GetDatasetType calls GetDatasetTypeFunc.
func (mock *StorerMock) GetDatasetType(ctx context.Context, datasetID string, authorised bool) (string, error) {
	if mock.GetDatasetTypeFunc == nil {
		panic("StorerMock.GetDatasetTypeFunc: method is nil but Storer.GetDatasetType was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		DatasetID  string
		Authorised bool
	}{
		Ctx:        ctx,
		DatasetID:  datasetID,
		Authorised: authorised,
	}
	mock.lockGetDatasetType.Lock()
	mock.calls.GetDatasetType = append(mock.calls.GetDatasetType, callInfo)
	mock.lockGetDatasetType.Unlock()
	return mock.GetDatasetTypeFunc(ctx, datasetID, authorised)
}

// GetDatasetTypeCalls gets all the calls that were made to GetDatasetType.
// Check the length with:
//
//	len(mockedStorer.GetDatasetTypeCalls())
func (mock *StorerMock) GetDatasetTypeCalls() []struct {
	Ctx        context.Context
	DatasetID  string
	Authorised bool
} {
	var calls []struct {
		Ctx        context.Context
		DatasetID  string
		Authorised bool
	}
	mock.lockGetDatasetType.RLock()
	calls = mock.calls.GetDatasetType
	mock.lockGetDatasetType.RUnlock()
	return calls
}

// GetDatasets calls GetDatasetsFunc.
func (mock *StorerMock) GetDatasets(ctx context.Context, offset int, limit int, authorised bool) ([]*models.DatasetUpdate, int, error) {
	if mock.GetDatasetsFunc == nil {
		panic("StorerMock.GetDatasetsFunc: method is nil but Storer.GetDatasets was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		Offset     int
		Limit      int
		Authorised bool
	}{
		Ctx:        ctx,
		Offset:     offset,
		Limit:      limit,
		Authorised: authorised,
	}
	mock.lockGetDatasets.Lock()
	mock.calls.GetDatasets = append(mock.calls.GetDatasets, callInfo)
	mock.lockGetDatasets.Unlock()
	return mock.GetDatasetsFunc(ctx, offset, limit, authorised)
}

// GetDatasetsCalls gets all the calls that were made to GetDatasets.
// Check the length with:
//
//	len(mockedStorer.GetDatasetsCalls())
func (mock *StorerMock) GetDatasetsCalls() []struct {
	Ctx        context.Context
	Offset     int
	Limit      int
	Authorised bool
} {
	var calls []struct {
		Ctx        context.Context
		Offset     int
		Limit      int
		Authorised bool
	}
	mock.lockGetDatasets.RLock()
	calls = mock.calls.GetDatasets
	mock.lockGetDatasets.RUnlock()
	return calls
}

// GetDatasetsByQueryParams calls GetDatasetsByQueryParamsFunc.
func (mock *StorerMock) GetDatasetsByQueryParams(ctx context.Context, ID string, datasetType string, offset int, limit int, authorised bool) ([]*models.DatasetUpdate, int, error) {
	if mock.GetDatasetsByQueryParamsFunc == nil {
		panic("StorerMock.GetDatasetsByQueryParamsFunc: method is nil but Storer.GetDatasetsByQueryParams was just called")
	}
	callInfo := struct {
		Ctx         context.Context
		ID          string
		DatasetType string
		Offset      int
		Limit       int
		Authorised  bool
	}{
		Ctx:         ctx,
		ID:          ID,
		DatasetType: datasetType,
		Offset:      offset,
		Limit:       limit,
		Authorised:  authorised,
	}
	mock.lockGetDatasetsByQueryParams.Lock()
	mock.calls.GetDatasetsByQueryParams = append(mock.calls.GetDatasetsByQueryParams, callInfo)
	mock.lockGetDatasetsByQueryParams.Unlock()
	return mock.GetDatasetsByQueryParamsFunc(ctx, ID, datasetType, offset, limit, authorised)
}

// GetDatasetsByQueryParamsCalls gets all the calls that were made to GetDatasetsByQueryParams.
// Check the length with:
//
//	len(mockedStorer.GetDatasetsByQueryParamsCalls())
func (mock *StorerMock) GetDatasetsByQueryParamsCalls() []struct {
	Ctx         context.Context
	ID          string
	DatasetType string
	Offset      int
	Limit       int
	Authorised  bool
} {
	var calls []struct {
		Ctx         context.Context
		ID          string
		DatasetType string
		Offset      int
		Limit       int
		Authorised  bool
	}
	mock.lockGetDatasetsByQueryParams.RLock()
	calls = mock.calls.GetDatasetsByQueryParams
	mock.lockGetDatasetsByQueryParams.RUnlock()
	return calls
}

// GetDimensionOptions calls GetDimensionOptionsFunc.
func (mock *StorerMock) GetDimensionOptions(ctx context.Context, version *models.Version, dimension string, offset int, limit int) ([]*models.PublicDimensionOption, int, error) {
	if mock.GetDimensionOptionsFunc == nil {
		panic("StorerMock.GetDimensionOptionsFunc: method is nil but Storer.GetDimensionOptions was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		Version   *models.Version
		Dimension string
		Offset    int
		Limit     int
	}{
		Ctx:       ctx,
		Version:   version,
		Dimension: dimension,
		Offset:    offset,
		Limit:     limit,
	}
	mock.lockGetDimensionOptions.Lock()
	mock.calls.GetDimensionOptions = append(mock.calls.GetDimensionOptions, callInfo)
	mock.lockGetDimensionOptions.Unlock()
	return mock.GetDimensionOptionsFunc(ctx, version, dimension, offset, limit)
}

// GetDimensionOptionsCalls gets all the calls that were made to GetDimensionOptions.
// Check the length with:
//
//	len(mockedStorer.GetDimensionOptionsCalls())
func (mock *StorerMock) GetDimensionOptionsCalls() []struct {
	Ctx       context.Context
	Version   *models.Version
	Dimension string
	Offset    int
	Limit     int
} {
	var calls []struct {
		Ctx       context.Context
		Version   *models.Version
		Dimension string
		Offset    int
		Limit     int
	}
	mock.lockGetDimensionOptions.RLock()
	calls = mock.calls.GetDimensionOptions
	mock.lockGetDimensionOptions.RUnlock()
	return calls
}

// GetDimensionOptionsFromIDs calls GetDimensionOptionsFromIDsFunc.
func (mock *StorerMock) GetDimensionOptionsFromIDs(ctx context.Context, version *models.Version, dimension string, ids []string) ([]*models.PublicDimensionOption, int, error) {
	if mock.GetDimensionOptionsFromIDsFunc == nil {
		panic("StorerMock.GetDimensionOptionsFromIDsFunc: method is nil but Storer.GetDimensionOptionsFromIDs was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		Version   *models.Version
		Dimension string
		Ids       []string
	}{
		Ctx:       ctx,
		Version:   version,
		Dimension: dimension,
		Ids:       ids,
	}
	mock.lockGetDimensionOptionsFromIDs.Lock()
	mock.calls.GetDimensionOptionsFromIDs = append(mock.calls.GetDimensionOptionsFromIDs, callInfo)
	mock.lockGetDimensionOptionsFromIDs.Unlock()
	return mock.GetDimensionOptionsFromIDsFunc(ctx, version, dimension, ids)
}

// GetDimensionOptionsFromIDsCalls gets all the calls that were made to GetDimensionOptionsFromIDs.
// Check the length with:
//
//	len(mockedStorer.GetDimensionOptionsFromIDsCalls())
func (mock *StorerMock) GetDimensionOptionsFromIDsCalls() []struct {
	Ctx       context.Context
	Version   *models.Version
	Dimension string
	Ids       []string
} {
	var calls []struct {
		Ctx       context.Context
		Version   *models.Version
		Dimension string
		Ids       []string
	}
	mock.lockGetDimensionOptionsFromIDs.RLock()
	calls = mock.calls.GetDimensionOptionsFromIDs
	mock.lockGetDimensionOptionsFromIDs.RUnlock()
	return calls
}

// GetDimensions calls GetDimensionsFunc.
func (mock *StorerMock) GetDimensions(ctx context.Context, versionID string) ([]bson.M, error) {
	if mock.GetDimensionsFunc == nil {
		panic("StorerMock.GetDimensionsFunc: method is nil but Storer.GetDimensions was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		VersionID string
	}{
		Ctx:       ctx,
		VersionID: versionID,
	}
	mock.lockGetDimensions.Lock()
	mock.calls.GetDimensions = append(mock.calls.GetDimensions, callInfo)
	mock.lockGetDimensions.Unlock()
	return mock.GetDimensionsFunc(ctx, versionID)
}

// GetDimensionsCalls gets all the calls that were made to GetDimensions.
// Check the length with:
//
//	len(mockedStorer.GetDimensionsCalls())
func (mock *StorerMock) GetDimensionsCalls() []struct {
	Ctx       context.Context
	VersionID string
} {
	var calls []struct {
		Ctx       context.Context
		VersionID string
	}
	mock.lockGetDimensions.RLock()
	calls = mock.calls.GetDimensions
	mock.lockGetDimensions.RUnlock()
	return calls
}

// GetDimensionsFromInstance calls GetDimensionsFromInstanceFunc.
func (mock *StorerMock) GetDimensionsFromInstance(ctx context.Context, ID string, offset int, limit int) ([]*models.DimensionOption, int, error) {
	if mock.GetDimensionsFromInstanceFunc == nil {
		panic("StorerMock.GetDimensionsFromInstanceFunc: method is nil but Storer.GetDimensionsFromInstance was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		ID     string
		Offset int
		Limit  int
	}{
		Ctx:    ctx,
		ID:     ID,
		Offset: offset,
		Limit:  limit,
	}
	mock.lockGetDimensionsFromInstance.Lock()
	mock.calls.GetDimensionsFromInstance = append(mock.calls.GetDimensionsFromInstance, callInfo)
	mock.lockGetDimensionsFromInstance.Unlock()
	return mock.GetDimensionsFromInstanceFunc(ctx, ID, offset, limit)
}

// GetDimensionsFromInstanceCalls gets all the calls that were made to GetDimensionsFromInstance.
// Check the length with:
//
//	len(mockedStorer.GetDimensionsFromInstanceCalls())
func (mock *StorerMock) GetDimensionsFromInstanceCalls() []struct {
	Ctx    context.Context
	ID     string
	Offset int
	Limit  int
} {
	var calls []struct {
		Ctx    context.Context
		ID     string
		Offset int
		Limit  int
	}
	mock.lockGetDimensionsFromInstance.RLock()
	calls = mock.calls.GetDimensionsFromInstance
	mock.lockGetDimensionsFromInstance.RUnlock()
	return calls
}

// GetEdition calls GetEditionFunc.
func (mock *StorerMock) GetEdition(ctx context.Context, ID string, editionID string, state string) (*models.EditionUpdate, error) {
	if mock.GetEditionFunc == nil {
		panic("StorerMock.GetEditionFunc: method is nil but Storer.GetEdition was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		ID        string
		EditionID string
		State     string
	}{
		Ctx:       ctx,
		ID:        ID,
		EditionID: editionID,
		State:     state,
	}
	mock.lockGetEdition.Lock()
	mock.calls.GetEdition = append(mock.calls.GetEdition, callInfo)
	mock.lockGetEdition.Unlock()
	return mock.GetEditionFunc(ctx, ID, editionID, state)
}

// GetEditionCalls gets all the calls that were made to GetEdition.
// Check the length with:
//
//	len(mockedStorer.GetEditionCalls())
func (mock *StorerMock) GetEditionCalls() []struct {
	Ctx       context.Context
	ID        string
	EditionID string
	State     string
} {
	var calls []struct {
		Ctx       context.Context
		ID        string
		EditionID string
		State     string
	}
	mock.lockGetEdition.RLock()
	calls = mock.calls.GetEdition
	mock.lockGetEdition.RUnlock()
	return calls
}

// GetEditions calls GetEditionsFunc.
func (mock *StorerMock) GetEditions(ctx context.Context, ID string, state string, offset int, limit int, authorised bool) ([]*models.EditionUpdate, int, error) {
	if mock.GetEditionsFunc == nil {
		panic("StorerMock.GetEditionsFunc: method is nil but Storer.GetEditions was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		ID         string
		State      string
		Offset     int
		Limit      int
		Authorised bool
	}{
		Ctx:        ctx,
		ID:         ID,
		State:      state,
		Offset:     offset,
		Limit:      limit,
		Authorised: authorised,
	}
	mock.lockGetEditions.Lock()
	mock.calls.GetEditions = append(mock.calls.GetEditions, callInfo)
	mock.lockGetEditions.Unlock()
	return mock.GetEditionsFunc(ctx, ID, state, offset, limit, authorised)
}

// GetEditionsCalls gets all the calls that were made to GetEditions.
// Check the length with:
//
//	len(mockedStorer.GetEditionsCalls())
func (mock *StorerMock) GetEditionsCalls() []struct {
	Ctx        context.Context
	ID         string
	State      string
	Offset     int
	Limit      int
	Authorised bool
} {
	var calls []struct {
		Ctx        context.Context
		ID         string
		State      string
		Offset     int
		Limit      int
		Authorised bool
	}
	mock.lockGetEditions.RLock()
	calls = mock.calls.GetEditions
	mock.lockGetEditions.RUnlock()
	return calls
}

// GetInstance calls GetInstanceFunc.
func (mock *StorerMock) GetInstance(ctx context.Context, ID string, eTagSelector string) (*models.Instance, error) {
	if mock.GetInstanceFunc == nil {
		panic("StorerMock.GetInstanceFunc: method is nil but Storer.GetInstance was just called")
	}
	callInfo := struct {
		Ctx          context.Context
		ID           string
		ETagSelector string
	}{
		Ctx:          ctx,
		ID:           ID,
		ETagSelector: eTagSelector,
	}
	mock.lockGetInstance.Lock()
	mock.calls.GetInstance = append(mock.calls.GetInstance, callInfo)
	mock.lockGetInstance.Unlock()
	return mock.GetInstanceFunc(ctx, ID, eTagSelector)
}

// GetInstanceCalls gets all the calls that were made to GetInstance.
// Check the length with:
//
//	len(mockedStorer.GetInstanceCalls())
func (mock *StorerMock) GetInstanceCalls() []struct {
	Ctx          context.Context
	ID           string
	ETagSelector string
} {
	var calls []struct {
		Ctx          context.Context
		ID           string
		ETagSelector string
	}
	mock.lockGetInstance.RLock()
	calls = mock.calls.GetInstance
	mock.lockGetInstance.RUnlock()
	return calls
}

// GetInstances calls GetInstancesFunc.
func (mock *StorerMock) GetInstances(ctx context.Context, states []string, datasets []string, offset int, limit int) ([]*models.Instance, int, error) {
	if mock.GetInstancesFunc == nil {
		panic("StorerMock.GetInstancesFunc: method is nil but Storer.GetInstances was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		States   []string
		Datasets []string
		Offset   int
		Limit    int
	}{
		Ctx:      ctx,
		States:   states,
		Datasets: datasets,
		Offset:   offset,
		Limit:    limit,
	}
	mock.lockGetInstances.Lock()
	mock.calls.GetInstances = append(mock.calls.GetInstances, callInfo)
	mock.lockGetInstances.Unlock()
	return mock.GetInstancesFunc(ctx, states, datasets, offset, limit)
}

// GetInstancesCalls gets all the calls that were made to GetInstances.
// Check the length with:
//
//	len(mockedStorer.GetInstancesCalls())
func (mock *StorerMock) GetInstancesCalls() []struct {
	Ctx      context.Context
	States   []string
	Datasets []string
	Offset   int
	Limit    int
} {
	var calls []struct {
		Ctx      context.Context
		States   []string
		Datasets []string
		Offset   int
		Limit    int
	}
	mock.lockGetInstances.RLock()
	calls = mock.calls.GetInstances
	mock.lockGetInstances.RUnlock()
	return calls
}

// GetLatestStaticVersionByState calls GetLatestStaticVersionByStateFunc.
func (mock *StorerMock) GetLatestStaticVersionByState(ctx context.Context, datasetID string, edition string, state string) (*models.Version, error) {
	if mock.GetLatestStaticVersionByStateFunc == nil {
		panic("StorerMock.GetLatestStaticVersionByStateFunc: method is nil but Storer.GetLatestStaticVersionByState was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		DatasetID string
		Edition   string
		State     string
	}{
		Ctx:       ctx,
		DatasetID: datasetID,
		Edition:   edition,
		State:     state,
	}
	mock.lockGetLatestStaticVersionByState.Lock()
	mock.calls.GetLatestStaticVersionByState = append(mock.calls.GetLatestStaticVersionByState, callInfo)
	mock.lockGetLatestStaticVersionByState.Unlock()
	return mock.GetLatestStaticVersionByStateFunc(ctx, datasetID, edition, state)
}

// GetLatestStaticVersionByStateCalls gets all the calls that were made to GetLatestStaticVersionByState.
// Check the length with:
//
//	len(mockedStorer.GetLatestStaticVersionByStateCalls())
func (mock *StorerMock) GetLatestStaticVersionByStateCalls() []struct {
	Ctx       context.Context
	DatasetID string
	Edition   string
	State     string
} {
	var calls []struct {
		Ctx       context.Context
		DatasetID string
		Edition   string
		State     string
	}
	mock.lockGetLatestStaticVersionByState.RLock()
	calls = mock.calls.GetLatestStaticVersionByState
	mock.lockGetLatestStaticVersionByState.RUnlock()
	return calls
}

// GetLatestVersionStatic calls GetLatestVersionStaticFunc.
func (mock *StorerMock) GetLatestVersionStatic(ctx context.Context, datasetID string, editionID string, state string) (*models.Version, error) {
	if mock.GetLatestVersionStaticFunc == nil {
		panic("StorerMock.GetLatestVersionStaticFunc: method is nil but Storer.GetLatestVersionStatic was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		DatasetID string
		EditionID string
		State     string
	}{
		Ctx:       ctx,
		DatasetID: datasetID,
		EditionID: editionID,
		State:     state,
	}
	mock.lockGetLatestVersionStatic.Lock()
	mock.calls.GetLatestVersionStatic = append(mock.calls.GetLatestVersionStatic, callInfo)
	mock.lockGetLatestVersionStatic.Unlock()
	return mock.GetLatestVersionStaticFunc(ctx, datasetID, editionID, state)
}

// GetLatestVersionStaticCalls gets all the calls that were made to GetLatestVersionStatic.
// Check the length with:
//
//	len(mockedStorer.GetLatestVersionStaticCalls())
func (mock *StorerMock) GetLatestVersionStaticCalls() []struct {
	Ctx       context.Context
	DatasetID string
	EditionID string
	State     string
} {
	var calls []struct {
		Ctx       context.Context
		DatasetID string
		EditionID string
		State     string
	}
	mock.lockGetLatestVersionStatic.RLock()
	calls = mock.calls.GetLatestVersionStatic
	mock.lockGetLatestVersionStatic.RUnlock()
	return calls
}

// GetNextVersion calls GetNextVersionFunc.
func (mock *StorerMock) GetNextVersion(ctx context.Context, datasetID string, editionID string) (int, error) {
	if mock.GetNextVersionFunc == nil {
		panic("StorerMock.GetNextVersionFunc: method is nil but Storer.GetNextVersion was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		DatasetID string
		EditionID string
	}{
		Ctx:       ctx,
		DatasetID: datasetID,
		EditionID: editionID,
	}
	mock.lockGetNextVersion.Lock()
	mock.calls.GetNextVersion = append(mock.calls.GetNextVersion, callInfo)
	mock.lockGetNextVersion.Unlock()
	return mock.GetNextVersionFunc(ctx, datasetID, editionID)
}

// GetNextVersionCalls gets all the calls that were made to GetNextVersion.
// Check the length with:
//
//	len(mockedStorer.GetNextVersionCalls())
func (mock *StorerMock) GetNextVersionCalls() []struct {
	Ctx       context.Context
	DatasetID string
	EditionID string
} {
	var calls []struct {
		Ctx       context.Context
		DatasetID string
		EditionID string
	}
	mock.lockGetNextVersion.RLock()
	calls = mock.calls.GetNextVersion
	mock.lockGetNextVersion.RUnlock()
	return calls
}

// GetStaticEditionsByState calls GetStaticEditionsByStateFunc.
func (mock *StorerMock) GetStaticEditionsByState(ctx context.Context, state string, offset int, limit int) ([]*models.Version, int, error) {
	if mock.GetStaticEditionsByStateFunc == nil {
		panic("StorerMock.GetStaticEditionsByStateFunc: method is nil but Storer.GetStaticEditionsByState was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		State  string
		Offset int
		Limit  int
	}{
		Ctx:    ctx,
		State:  state,
		Offset: offset,
		Limit:  limit,
	}
	mock.lockGetStaticEditionsByState.Lock()
	mock.calls.GetStaticEditionsByState = append(mock.calls.GetStaticEditionsByState, callInfo)
	mock.lockGetStaticEditionsByState.Unlock()
	return mock.GetStaticEditionsByStateFunc(ctx, state, offset, limit)
}

// GetStaticEditionsByStateCalls gets all the calls that were made to GetStaticEditionsByState.
// Check the length with:
//
//	len(mockedStorer.GetStaticEditionsByStateCalls())
func (mock *StorerMock) GetStaticEditionsByStateCalls() []struct {
	Ctx    context.Context
	State  string
	Offset int
	Limit  int
} {
	var calls []struct {
		Ctx    context.Context
		State  string
		Offset int
		Limit  int
	}
	mock.lockGetStaticEditionsByState.RLock()
	calls = mock.calls.GetStaticEditionsByState
	mock.lockGetStaticEditionsByState.RUnlock()
	return calls
}

// GetUniqueDimensionAndOptions calls GetUniqueDimensionAndOptionsFunc.
func (mock *StorerMock) GetUniqueDimensionAndOptions(ctx context.Context, ID string, dimension string) ([]*string, int, error) {
	if mock.GetUniqueDimensionAndOptionsFunc == nil {
		panic("StorerMock.GetUniqueDimensionAndOptionsFunc: method is nil but Storer.GetUniqueDimensionAndOptions was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		ID        string
		Dimension string
	}{
		Ctx:       ctx,
		ID:        ID,
		Dimension: dimension,
	}
	mock.lockGetUniqueDimensionAndOptions.Lock()
	mock.calls.GetUniqueDimensionAndOptions = append(mock.calls.GetUniqueDimensionAndOptions, callInfo)
	mock.lockGetUniqueDimensionAndOptions.Unlock()
	return mock.GetUniqueDimensionAndOptionsFunc(ctx, ID, dimension)
}

// GetUniqueDimensionAndOptionsCalls gets all the calls that were made to GetUniqueDimensionAndOptions.
// Check the length with:
//
//	len(mockedStorer.GetUniqueDimensionAndOptionsCalls())
func (mock *StorerMock) GetUniqueDimensionAndOptionsCalls() []struct {
	Ctx       context.Context
	ID        string
	Dimension string
} {
	var calls []struct {
		Ctx       context.Context
		ID        string
		Dimension string
	}
	mock.lockGetUniqueDimensionAndOptions.RLock()
	calls = mock.calls.GetUniqueDimensionAndOptions
	mock.lockGetUniqueDimensionAndOptions.RUnlock()
	return calls
}

// GetUnpublishedDatasetStatic calls GetUnpublishedDatasetStaticFunc.
func (mock *StorerMock) GetUnpublishedDatasetStatic(ctx context.Context, id string) (*models.Dataset, error) {
	if mock.GetUnpublishedDatasetStaticFunc == nil {
		panic("StorerMock.GetUnpublishedDatasetStaticFunc: method is nil but Storer.GetUnpublishedDatasetStatic was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  string
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockGetUnpublishedDatasetStatic.Lock()
	mock.calls.GetUnpublishedDatasetStatic = append(mock.calls.GetUnpublishedDatasetStatic, callInfo)
	mock.lockGetUnpublishedDatasetStatic.Unlock()
	return mock.GetUnpublishedDatasetStaticFunc(ctx, id)
}

// GetUnpublishedDatasetStaticCalls gets all the calls that were made to GetUnpublishedDatasetStatic.
// Check the length with:
//
//	len(mockedStorer.GetUnpublishedDatasetStaticCalls())
func (mock *StorerMock) GetUnpublishedDatasetStaticCalls() []struct {
	Ctx context.Context
	ID  string
} {
	var calls []struct {
		Ctx context.Context
		ID  string
	}
	mock.lockGetUnpublishedDatasetStatic.RLock()
	calls = mock.calls.GetUnpublishedDatasetStatic
	mock.lockGetUnpublishedDatasetStatic.RUnlock()
	return calls
}

// GetVersion calls GetVersionFunc.
func (mock *StorerMock) GetVersion(ctx context.Context, datasetID string, editionID string, version int, state string) (*models.Version, error) {
	if mock.GetVersionFunc == nil {
		panic("StorerMock.GetVersionFunc: method is nil but Storer.GetVersion was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		DatasetID string
		EditionID string
		Version   int
		State     string
	}{
		Ctx:       ctx,
		DatasetID: datasetID,
		EditionID: editionID,
		Version:   version,
		State:     state,
	}
	mock.lockGetVersion.Lock()
	mock.calls.GetVersion = append(mock.calls.GetVersion, callInfo)
	mock.lockGetVersion.Unlock()
	return mock.GetVersionFunc(ctx, datasetID, editionID, version, state)
}

// GetVersionCalls gets all the calls that were made to GetVersion.
// Check the length with:
//
//	len(mockedStorer.GetVersionCalls())
func (mock *StorerMock) GetVersionCalls() []struct {
	Ctx       context.Context
	DatasetID string
	EditionID string
	Version   int
	State     string
} {
	var calls []struct {
		Ctx       context.Context
		DatasetID string
		EditionID string
		Version   int
		State     string
	}
	mock.lockGetVersion.RLock()
	calls = mock.calls.GetVersion
	mock.lockGetVersion.RUnlock()
	return calls
}

// GetVersionStatic calls GetVersionStaticFunc.
func (mock *StorerMock) GetVersionStatic(ctx context.Context, datasetID string, editionID string, version int, state string) (*models.Version, error) {
	if mock.GetVersionStaticFunc == nil {
		panic("StorerMock.GetVersionStaticFunc: method is nil but Storer.GetVersionStatic was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		DatasetID string
		EditionID string
		Version   int
		State     string
	}{
		Ctx:       ctx,
		DatasetID: datasetID,
		EditionID: editionID,
		Version:   version,
		State:     state,
	}
	mock.lockGetVersionStatic.Lock()
	mock.calls.GetVersionStatic = append(mock.calls.GetVersionStatic, callInfo)
	mock.lockGetVersionStatic.Unlock()
	return mock.GetVersionStaticFunc(ctx, datasetID, editionID, version, state)
}

// GetVersionStaticCalls gets all the calls that were made to GetVersionStatic.
// Check the length with:
//
//	len(mockedStorer.GetVersionStaticCalls())
func (mock *StorerMock) GetVersionStaticCalls() []struct {
	Ctx       context.Context
	DatasetID string
	EditionID string
	Version   int
	State     string
} {
	var calls []struct {
		Ctx       context.Context
		DatasetID string
		EditionID string
		Version   int
		State     string
	}
	mock.lockGetVersionStatic.RLock()
	calls = mock.calls.GetVersionStatic
	mock.lockGetVersionStatic.RUnlock()
	return calls
}

// GetVersions calls GetVersionsFunc.
func (mock *StorerMock) GetVersions(ctx context.Context, datasetID string, editionID string, state string, offset int, limit int) ([]models.Version, int, error) {
	if mock.GetVersionsFunc == nil {
		panic("StorerMock.GetVersionsFunc: method is nil but Storer.GetVersions was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		DatasetID string
		EditionID string
		State     string
		Offset    int
		Limit     int
	}{
		Ctx:       ctx,
		DatasetID: datasetID,
		EditionID: editionID,
		State:     state,
		Offset:    offset,
		Limit:     limit,
	}
	mock.lockGetVersions.Lock()
	mock.calls.GetVersions = append(mock.calls.GetVersions, callInfo)
	mock.lockGetVersions.Unlock()
	return mock.GetVersionsFunc(ctx, datasetID, editionID, state, offset, limit)
}

// GetVersionsCalls gets all the calls that were made to GetVersions.
// Check the length with:
//
//	len(mockedStorer.GetVersionsCalls())
func (mock *StorerMock) GetVersionsCalls() []struct {
	Ctx       context.Context
	DatasetID string
	EditionID string
	State     string
	Offset    int
	Limit     int
} {
	var calls []struct {
		Ctx       context.Context
		DatasetID string
		EditionID string
		State     string
		Offset    int
		Limit     int
	}
	mock.lockGetVersions.RLock()
	calls = mock.calls.GetVersions
	mock.lockGetVersions.RUnlock()
	return calls
}

// GetVersionsStatic calls GetVersionsStaticFunc.
func (mock *StorerMock) GetVersionsStatic(ctx context.Context, datasetID string, edition string, state string, offset int, limit int) ([]models.Version, int, error) {
	if mock.GetVersionsStaticFunc == nil {
		panic("StorerMock.GetVersionsStaticFunc: method is nil but Storer.GetVersionsStatic was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		DatasetID string
		Edition   string
		State     string
		Offset    int
		Limit     int
	}{
		Ctx:       ctx,
		DatasetID: datasetID,
		Edition:   edition,
		State:     state,
		Offset:    offset,
		Limit:     limit,
	}
	mock.lockGetVersionsStatic.Lock()
	mock.calls.GetVersionsStatic = append(mock.calls.GetVersionsStatic, callInfo)
	mock.lockGetVersionsStatic.Unlock()
	return mock.GetVersionsStaticFunc(ctx, datasetID, edition, state, offset, limit)
}

// GetVersionsStaticCalls gets all the calls that were made to GetVersionsStatic.
// Check the length with:
//
//	len(mockedStorer.GetVersionsStaticCalls())
func (mock *StorerMock) GetVersionsStaticCalls() []struct {
	Ctx       context.Context
	DatasetID string
	Edition   string
	State     string
	Offset    int
	Limit     int
} {
	var calls []struct {
		Ctx       context.Context
		DatasetID string
		Edition   string
		State     string
		Offset    int
		Limit     int
	}
	mock.lockGetVersionsStatic.RLock()
	calls = mock.calls.GetVersionsStatic
	mock.lockGetVersionsStatic.RUnlock()
	return calls
}

// RemoveDatasetVersionAndEditionLinks calls RemoveDatasetVersionAndEditionLinksFunc.
func (mock *StorerMock) RemoveDatasetVersionAndEditionLinks(ctx context.Context, id string) error {
	if mock.RemoveDatasetVersionAndEditionLinksFunc == nil {
		panic("StorerMock.RemoveDatasetVersionAndEditionLinksFunc: method is nil but Storer.RemoveDatasetVersionAndEditionLinks was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  string
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockRemoveDatasetVersionAndEditionLinks.Lock()
	mock.calls.RemoveDatasetVersionAndEditionLinks = append(mock.calls.RemoveDatasetVersionAndEditionLinks, callInfo)
	mock.lockRemoveDatasetVersionAndEditionLinks.Unlock()
	return mock.RemoveDatasetVersionAndEditionLinksFunc(ctx, id)
}

// RemoveDatasetVersionAndEditionLinksCalls gets all the calls that were made to RemoveDatasetVersionAndEditionLinks.
// Check the length with:
//
//	len(mockedStorer.RemoveDatasetVersionAndEditionLinksCalls())
func (mock *StorerMock) RemoveDatasetVersionAndEditionLinksCalls() []struct {
	Ctx context.Context
	ID  string
} {
	var calls []struct {
		Ctx context.Context
		ID  string
	}
	mock.lockRemoveDatasetVersionAndEditionLinks.RLock()
	calls = mock.calls.RemoveDatasetVersionAndEditionLinks
	mock.lockRemoveDatasetVersionAndEditionLinks.RUnlock()
	return calls
}

// SetInstanceIsPublished calls SetInstanceIsPublishedFunc.
func (mock *StorerMock) SetInstanceIsPublished(ctx context.Context, instanceID string) error {
	if mock.SetInstanceIsPublishedFunc == nil {
		panic("StorerMock.SetInstanceIsPublishedFunc: method is nil but Storer.SetInstanceIsPublished was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		InstanceID string
	}{
		Ctx:        ctx,
		InstanceID: instanceID,
	}
	mock.lockSetInstanceIsPublished.Lock()
	mock.calls.SetInstanceIsPublished = append(mock.calls.SetInstanceIsPublished, callInfo)
	mock.lockSetInstanceIsPublished.Unlock()
	return mock.SetInstanceIsPublishedFunc(ctx, instanceID)
}

// SetInstanceIsPublishedCalls gets all the calls that were made to SetInstanceIsPublished.
// Check the length with:
//
//	len(mockedStorer.SetInstanceIsPublishedCalls())
func (mock *StorerMock) SetInstanceIsPublishedCalls() []struct {
	Ctx        context.Context
	InstanceID string
} {
	var calls []struct {
		Ctx        context.Context
		InstanceID string
	}
	mock.lockSetInstanceIsPublished.RLock()
	calls = mock.calls.SetInstanceIsPublished
	mock.lockSetInstanceIsPublished.RUnlock()
	return calls
}

// UnlockInstance calls UnlockInstanceFunc.
func (mock *StorerMock) UnlockInstance(ctx context.Context, lockID string) {
	if mock.UnlockInstanceFunc == nil {
		panic("StorerMock.UnlockInstanceFunc: method is nil but Storer.UnlockInstance was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		LockID string
	}{
		Ctx:    ctx,
		LockID: lockID,
	}
	mock.lockUnlockInstance.Lock()
	mock.calls.UnlockInstance = append(mock.calls.UnlockInstance, callInfo)
	mock.lockUnlockInstance.Unlock()
	mock.UnlockInstanceFunc(ctx, lockID)
}

// UnlockInstanceCalls gets all the calls that were made to UnlockInstance.
// Check the length with:
//
//	len(mockedStorer.UnlockInstanceCalls())
func (mock *StorerMock) UnlockInstanceCalls() []struct {
	Ctx    context.Context
	LockID string
} {
	var calls []struct {
		Ctx    context.Context
		LockID string
	}
	mock.lockUnlockInstance.RLock()
	calls = mock.calls.UnlockInstance
	mock.lockUnlockInstance.RUnlock()
	return calls
}

// UnlockVersions calls UnlockVersionsFunc.
func (mock *StorerMock) UnlockVersions(ctx context.Context, lockID string) {
	if mock.UnlockVersionsFunc == nil {
		panic("StorerMock.UnlockVersionsFunc: method is nil but Storer.UnlockVersions was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		LockID string
	}{
		Ctx:    ctx,
		LockID: lockID,
	}
	mock.lockUnlockVersions.Lock()
	mock.calls.UnlockVersions = append(mock.calls.UnlockVersions, callInfo)
	mock.lockUnlockVersions.Unlock()
	mock.UnlockVersionsFunc(ctx, lockID)
}

// UnlockVersionsCalls gets all the calls that were made to UnlockVersions.
// Check the length with:
//
//	len(mockedStorer.UnlockVersionsCalls())
func (mock *StorerMock) UnlockVersionsCalls() []struct {
	Ctx    context.Context
	LockID string
} {
	var calls []struct {
		Ctx    context.Context
		LockID string
	}
	mock.lockUnlockVersions.RLock()
	calls = mock.calls.UnlockVersions
	mock.lockUnlockVersions.RUnlock()
	return calls
}

// UpdateBuildHierarchyTaskState calls UpdateBuildHierarchyTaskStateFunc.
func (mock *StorerMock) UpdateBuildHierarchyTaskState(ctx context.Context, currentInstance *models.Instance, dimension string, state string, eTagSelector string) (string, error) {
	if mock.UpdateBuildHierarchyTaskStateFunc == nil {
		panic("StorerMock.UpdateBuildHierarchyTaskStateFunc: method is nil but Storer.UpdateBuildHierarchyTaskState was just called")
	}
	callInfo := struct {
		Ctx             context.Context
		CurrentInstance *models.Instance
		Dimension       string
		State           string
		ETagSelector    string
	}{
		Ctx:             ctx,
		CurrentInstance: currentInstance,
		Dimension:       dimension,
		State:           state,
		ETagSelector:    eTagSelector,
	}
	mock.lockUpdateBuildHierarchyTaskState.Lock()
	mock.calls.UpdateBuildHierarchyTaskState = append(mock.calls.UpdateBuildHierarchyTaskState, callInfo)
	mock.lockUpdateBuildHierarchyTaskState.Unlock()
	return mock.UpdateBuildHierarchyTaskStateFunc(ctx, currentInstance, dimension, state, eTagSelector)
}

// UpdateBuildHierarchyTaskStateCalls gets all the calls that were made to UpdateBuildHierarchyTaskState.
// Check the length with:
//
//	len(mockedStorer.UpdateBuildHierarchyTaskStateCalls())
func (mock *StorerMock) UpdateBuildHierarchyTaskStateCalls() []struct {
	Ctx             context.Context
	CurrentInstance *models.Instance
	Dimension       string
	State           string
	ETagSelector    string
} {
	var calls []struct {
		Ctx             context.Context
		CurrentInstance *models.Instance
		Dimension       string
		State           string
		ETagSelector    string
	}
	mock.lockUpdateBuildHierarchyTaskState.RLock()
	calls = mock.calls.UpdateBuildHierarchyTaskState
	mock.lockUpdateBuildHierarchyTaskState.RUnlock()
	return calls
}

// UpdateBuildSearchTaskState calls UpdateBuildSearchTaskStateFunc.
func (mock *StorerMock) UpdateBuildSearchTaskState(ctx context.Context, currentInstance *models.Instance, dimension string, state string, eTagSelector string) (string, error) {
	if mock.UpdateBuildSearchTaskStateFunc == nil {
		panic("StorerMock.UpdateBuildSearchTaskStateFunc: method is nil but Storer.UpdateBuildSearchTaskState was just called")
	}
	callInfo := struct {
		Ctx             context.Context
		CurrentInstance *models.Instance
		Dimension       string
		State           string
		ETagSelector    string
	}{
		Ctx:             ctx,
		CurrentInstance: currentInstance,
		Dimension:       dimension,
		State:           state,
		ETagSelector:    eTagSelector,
	}
	mock.lockUpdateBuildSearchTaskState.Lock()
	mock.calls.UpdateBuildSearchTaskState = append(mock.calls.UpdateBuildSearchTaskState, callInfo)
	mock.lockUpdateBuildSearchTaskState.Unlock()
	return mock.UpdateBuildSearchTaskStateFunc(ctx, currentInstance, dimension, state, eTagSelector)
}

// UpdateBuildSearchTaskStateCalls gets all the calls that were made to UpdateBuildSearchTaskState.
// Check the length with:
//
//	len(mockedStorer.UpdateBuildSearchTaskStateCalls())
func (mock *StorerMock) UpdateBuildSearchTaskStateCalls() []struct {
	Ctx             context.Context
	CurrentInstance *models.Instance
	Dimension       string
	State           string
	ETagSelector    string
} {
	var calls []struct {
		Ctx             context.Context
		CurrentInstance *models.Instance
		Dimension       string
		State           string
		ETagSelector    string
	}
	mock.lockUpdateBuildSearchTaskState.RLock()
	calls = mock.calls.UpdateBuildSearchTaskState
	mock.lockUpdateBuildSearchTaskState.RUnlock()
	return calls
}

// UpdateDataset calls UpdateDatasetFunc.
func (mock *StorerMock) UpdateDataset(ctx context.Context, ID string, dataset *models.Dataset, currentState string) error {
	if mock.UpdateDatasetFunc == nil {
		panic("StorerMock.UpdateDatasetFunc: method is nil but Storer.UpdateDataset was just called")
	}
	callInfo := struct {
		Ctx          context.Context
		ID           string
		Dataset      *models.Dataset
		CurrentState string
	}{
		Ctx:          ctx,
		ID:           ID,
		Dataset:      dataset,
		CurrentState: currentState,
	}
	mock.lockUpdateDataset.Lock()
	mock.calls.UpdateDataset = append(mock.calls.UpdateDataset, callInfo)
	mock.lockUpdateDataset.Unlock()
	return mock.UpdateDatasetFunc(ctx, ID, dataset, currentState)
}

// UpdateDatasetCalls gets all the calls that were made to UpdateDataset.
// Check the length with:
//
//	len(mockedStorer.UpdateDatasetCalls())
func (mock *StorerMock) UpdateDatasetCalls() []struct {
	Ctx          context.Context
	ID           string
	Dataset      *models.Dataset
	CurrentState string
} {
	var calls []struct {
		Ctx          context.Context
		ID           string
		Dataset      *models.Dataset
		CurrentState string
	}
	mock.lockUpdateDataset.RLock()
	calls = mock.calls.UpdateDataset
	mock.lockUpdateDataset.RUnlock()
	return calls
}

// UpdateDatasetWithAssociation calls UpdateDatasetWithAssociationFunc.
func (mock *StorerMock) UpdateDatasetWithAssociation(ctx context.Context, ID string, state string, version *models.Version) error {
	if mock.UpdateDatasetWithAssociationFunc == nil {
		panic("StorerMock.UpdateDatasetWithAssociationFunc: method is nil but Storer.UpdateDatasetWithAssociation was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		ID      string
		State   string
		Version *models.Version
	}{
		Ctx:     ctx,
		ID:      ID,
		State:   state,
		Version: version,
	}
	mock.lockUpdateDatasetWithAssociation.Lock()
	mock.calls.UpdateDatasetWithAssociation = append(mock.calls.UpdateDatasetWithAssociation, callInfo)
	mock.lockUpdateDatasetWithAssociation.Unlock()
	return mock.UpdateDatasetWithAssociationFunc(ctx, ID, state, version)
}

// UpdateDatasetWithAssociationCalls gets all the calls that were made to UpdateDatasetWithAssociation.
// Check the length with:
//
//	len(mockedStorer.UpdateDatasetWithAssociationCalls())
func (mock *StorerMock) UpdateDatasetWithAssociationCalls() []struct {
	Ctx     context.Context
	ID      string
	State   string
	Version *models.Version
} {
	var calls []struct {
		Ctx     context.Context
		ID      string
		State   string
		Version *models.Version
	}
	mock.lockUpdateDatasetWithAssociation.RLock()
	calls = mock.calls.UpdateDatasetWithAssociation
	mock.lockUpdateDatasetWithAssociation.RUnlock()
	return calls
}

// UpdateDimensionsNodeIDAndOrder calls UpdateDimensionsNodeIDAndOrderFunc.
func (mock *StorerMock) UpdateDimensionsNodeIDAndOrder(ctx context.Context, updates []*models.DimensionOption) error {
	if mock.UpdateDimensionsNodeIDAndOrderFunc == nil {
		panic("StorerMock.UpdateDimensionsNodeIDAndOrderFunc: method is nil but Storer.UpdateDimensionsNodeIDAndOrder was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Updates []*models.DimensionOption
	}{
		Ctx:     ctx,
		Updates: updates,
	}
	mock.lockUpdateDimensionsNodeIDAndOrder.Lock()
	mock.calls.UpdateDimensionsNodeIDAndOrder = append(mock.calls.UpdateDimensionsNodeIDAndOrder, callInfo)
	mock.lockUpdateDimensionsNodeIDAndOrder.Unlock()
	return mock.UpdateDimensionsNodeIDAndOrderFunc(ctx, updates)
}

// UpdateDimensionsNodeIDAndOrderCalls gets all the calls that were made to UpdateDimensionsNodeIDAndOrder.
// Check the length with:
//
//	len(mockedStorer.UpdateDimensionsNodeIDAndOrderCalls())
func (mock *StorerMock) UpdateDimensionsNodeIDAndOrderCalls() []struct {
	Ctx     context.Context
	Updates []*models.DimensionOption
} {
	var calls []struct {
		Ctx     context.Context
		Updates []*models.DimensionOption
	}
	mock.lockUpdateDimensionsNodeIDAndOrder.RLock()
	calls = mock.calls.UpdateDimensionsNodeIDAndOrder
	mock.lockUpdateDimensionsNodeIDAndOrder.RUnlock()
	return calls
}

// UpdateETagForOptions calls UpdateETagForOptionsFunc.
func (mock *StorerMock) UpdateETagForOptions(ctx context.Context, currentInstance *models.Instance, upserts []*models.CachedDimensionOption, updates []*models.DimensionOption, eTagSelector string) (string, error) {
	if mock.UpdateETagForOptionsFunc == nil {
		panic("StorerMock.UpdateETagForOptionsFunc: method is nil but Storer.UpdateETagForOptions was just called")
	}
	callInfo := struct {
		Ctx             context.Context
		CurrentInstance *models.Instance
		Upserts         []*models.CachedDimensionOption
		Updates         []*models.DimensionOption
		ETagSelector    string
	}{
		Ctx:             ctx,
		CurrentInstance: currentInstance,
		Upserts:         upserts,
		Updates:         updates,
		ETagSelector:    eTagSelector,
	}
	mock.lockUpdateETagForOptions.Lock()
	mock.calls.UpdateETagForOptions = append(mock.calls.UpdateETagForOptions, callInfo)
	mock.lockUpdateETagForOptions.Unlock()
	return mock.UpdateETagForOptionsFunc(ctx, currentInstance, upserts, updates, eTagSelector)
}

// UpdateETagForOptionsCalls gets all the calls that were made to UpdateETagForOptions.
// Check the length with:
//
//	len(mockedStorer.UpdateETagForOptionsCalls())
func (mock *StorerMock) UpdateETagForOptionsCalls() []struct {
	Ctx             context.Context
	CurrentInstance *models.Instance
	Upserts         []*models.CachedDimensionOption
	Updates         []*models.DimensionOption
	ETagSelector    string
} {
	var calls []struct {
		Ctx             context.Context
		CurrentInstance *models.Instance
		Upserts         []*models.CachedDimensionOption
		Updates         []*models.DimensionOption
		ETagSelector    string
	}
	mock.lockUpdateETagForOptions.RLock()
	calls = mock.calls.UpdateETagForOptions
	mock.lockUpdateETagForOptions.RUnlock()
	return calls
}

// UpdateImportObservationsTaskState calls UpdateImportObservationsTaskStateFunc.
func (mock *StorerMock) UpdateImportObservationsTaskState(ctx context.Context, currentInstance *models.Instance, state string, eTagSelector string) (string, error) {
	if mock.UpdateImportObservationsTaskStateFunc == nil {
		panic("StorerMock.UpdateImportObservationsTaskStateFunc: method is nil but Storer.UpdateImportObservationsTaskState was just called")
	}
	callInfo := struct {
		Ctx             context.Context
		CurrentInstance *models.Instance
		State           string
		ETagSelector    string
	}{
		Ctx:             ctx,
		CurrentInstance: currentInstance,
		State:           state,
		ETagSelector:    eTagSelector,
	}
	mock.lockUpdateImportObservationsTaskState.Lock()
	mock.calls.UpdateImportObservationsTaskState = append(mock.calls.UpdateImportObservationsTaskState, callInfo)
	mock.lockUpdateImportObservationsTaskState.Unlock()
	return mock.UpdateImportObservationsTaskStateFunc(ctx, currentInstance, state, eTagSelector)
}

// UpdateImportObservationsTaskStateCalls gets all the calls that were made to UpdateImportObservationsTaskState.
// Check the length with:
//
//	len(mockedStorer.UpdateImportObservationsTaskStateCalls())
func (mock *StorerMock) UpdateImportObservationsTaskStateCalls() []struct {
	Ctx             context.Context
	CurrentInstance *models.Instance
	State           string
	ETagSelector    string
} {
	var calls []struct {
		Ctx             context.Context
		CurrentInstance *models.Instance
		State           string
		ETagSelector    string
	}
	mock.lockUpdateImportObservationsTaskState.RLock()
	calls = mock.calls.UpdateImportObservationsTaskState
	mock.lockUpdateImportObservationsTaskState.RUnlock()
	return calls
}

// UpdateInstance calls UpdateInstanceFunc.
func (mock *StorerMock) UpdateInstance(ctx context.Context, currentInstance *models.Instance, updatedInstance *models.Instance, eTagSelector string) (string, error) {
	if mock.UpdateInstanceFunc == nil {
		panic("StorerMock.UpdateInstanceFunc: method is nil but Storer.UpdateInstance was just called")
	}
	callInfo := struct {
		Ctx             context.Context
		CurrentInstance *models.Instance
		UpdatedInstance *models.Instance
		ETagSelector    string
	}{
		Ctx:             ctx,
		CurrentInstance: currentInstance,
		UpdatedInstance: updatedInstance,
		ETagSelector:    eTagSelector,
	}
	mock.lockUpdateInstance.Lock()
	mock.calls.UpdateInstance = append(mock.calls.UpdateInstance, callInfo)
	mock.lockUpdateInstance.Unlock()
	return mock.UpdateInstanceFunc(ctx, currentInstance, updatedInstance, eTagSelector)
}

// UpdateInstanceCalls gets all the calls that were made to UpdateInstance.
// Check the length with:
//
//	len(mockedStorer.UpdateInstanceCalls())
func (mock *StorerMock) UpdateInstanceCalls() []struct {
	Ctx             context.Context
	CurrentInstance *models.Instance
	UpdatedInstance *models.Instance
	ETagSelector    string
} {
	var calls []struct {
		Ctx             context.Context
		CurrentInstance *models.Instance
		UpdatedInstance *models.Instance
		ETagSelector    string
	}
	mock.lockUpdateInstance.RLock()
	calls = mock.calls.UpdateInstance
	mock.lockUpdateInstance.RUnlock()
	return calls
}

// UpdateMetadata calls UpdateMetadataFunc.
func (mock *StorerMock) UpdateMetadata(ctx context.Context, datasetID string, versionID string, versionEtag string, updatedDataset *models.Dataset, updatedVersion *models.Version) error {
	if mock.UpdateMetadataFunc == nil {
		panic("StorerMock.UpdateMetadataFunc: method is nil but Storer.UpdateMetadata was just called")
	}
	callInfo := struct {
		Ctx            context.Context
		DatasetID      string
		VersionID      string
		VersionEtag    string
		UpdatedDataset *models.Dataset
		UpdatedVersion *models.Version
	}{
		Ctx:            ctx,
		DatasetID:      datasetID,
		VersionID:      versionID,
		VersionEtag:    versionEtag,
		UpdatedDataset: updatedDataset,
		UpdatedVersion: updatedVersion,
	}
	mock.lockUpdateMetadata.Lock()
	mock.calls.UpdateMetadata = append(mock.calls.UpdateMetadata, callInfo)
	mock.lockUpdateMetadata.Unlock()
	return mock.UpdateMetadataFunc(ctx, datasetID, versionID, versionEtag, updatedDataset, updatedVersion)
}

// UpdateMetadataCalls gets all the calls that were made to UpdateMetadata.
// Check the length with:
//
//	len(mockedStorer.UpdateMetadataCalls())
func (mock *StorerMock) UpdateMetadataCalls() []struct {
	Ctx            context.Context
	DatasetID      string
	VersionID      string
	VersionEtag    string
	UpdatedDataset *models.Dataset
	UpdatedVersion *models.Version
} {
	var calls []struct {
		Ctx            context.Context
		DatasetID      string
		VersionID      string
		VersionEtag    string
		UpdatedDataset *models.Dataset
		UpdatedVersion *models.Version
	}
	mock.lockUpdateMetadata.RLock()
	calls = mock.calls.UpdateMetadata
	mock.lockUpdateMetadata.RUnlock()
	return calls
}

// UpdateObservationInserted calls UpdateObservationInsertedFunc.
func (mock *StorerMock) UpdateObservationInserted(ctx context.Context, currentInstance *models.Instance, observationInserted int64, eTagSelector string) (string, error) {
	if mock.UpdateObservationInsertedFunc == nil {
		panic("StorerMock.UpdateObservationInsertedFunc: method is nil but Storer.UpdateObservationInserted was just called")
	}
	callInfo := struct {
		Ctx                 context.Context
		CurrentInstance     *models.Instance
		ObservationInserted int64
		ETagSelector        string
	}{
		Ctx:                 ctx,
		CurrentInstance:     currentInstance,
		ObservationInserted: observationInserted,
		ETagSelector:        eTagSelector,
	}
	mock.lockUpdateObservationInserted.Lock()
	mock.calls.UpdateObservationInserted = append(mock.calls.UpdateObservationInserted, callInfo)
	mock.lockUpdateObservationInserted.Unlock()
	return mock.UpdateObservationInsertedFunc(ctx, currentInstance, observationInserted, eTagSelector)
}

// UpdateObservationInsertedCalls gets all the calls that were made to UpdateObservationInserted.
// Check the length with:
//
//	len(mockedStorer.UpdateObservationInsertedCalls())
func (mock *StorerMock) UpdateObservationInsertedCalls() []struct {
	Ctx                 context.Context
	CurrentInstance     *models.Instance
	ObservationInserted int64
	ETagSelector        string
} {
	var calls []struct {
		Ctx                 context.Context
		CurrentInstance     *models.Instance
		ObservationInserted int64
		ETagSelector        string
	}
	mock.lockUpdateObservationInserted.RLock()
	calls = mock.calls.UpdateObservationInserted
	mock.lockUpdateObservationInserted.RUnlock()
	return calls
}

// UpdateVersion calls UpdateVersionFunc.
func (mock *StorerMock) UpdateVersion(ctx context.Context, currentVersion *models.Version, version *models.Version, eTagSelector string) (string, error) {
	if mock.UpdateVersionFunc == nil {
		panic("StorerMock.UpdateVersionFunc: method is nil but Storer.UpdateVersion was just called")
	}
	callInfo := struct {
		Ctx            context.Context
		CurrentVersion *models.Version
		Version        *models.Version
		ETagSelector   string
	}{
		Ctx:            ctx,
		CurrentVersion: currentVersion,
		Version:        version,
		ETagSelector:   eTagSelector,
	}
	mock.lockUpdateVersion.Lock()
	mock.calls.UpdateVersion = append(mock.calls.UpdateVersion, callInfo)
	mock.lockUpdateVersion.Unlock()
	return mock.UpdateVersionFunc(ctx, currentVersion, version, eTagSelector)
}

// UpdateVersionCalls gets all the calls that were made to UpdateVersion.
// Check the length with:
//
//	len(mockedStorer.UpdateVersionCalls())
func (mock *StorerMock) UpdateVersionCalls() []struct {
	Ctx            context.Context
	CurrentVersion *models.Version
	Version        *models.Version
	ETagSelector   string
} {
	var calls []struct {
		Ctx            context.Context
		CurrentVersion *models.Version
		Version        *models.Version
		ETagSelector   string
	}
	mock.lockUpdateVersion.RLock()
	calls = mock.calls.UpdateVersion
	mock.lockUpdateVersion.RUnlock()
	return calls
}

// UpdateVersionStatic calls UpdateVersionStaticFunc.
func (mock *StorerMock) UpdateVersionStatic(ctx context.Context, currentVersion *models.Version, versionUpdate *models.Version, eTagSelector string) (string, error) {
	if mock.UpdateVersionStaticFunc == nil {
		panic("StorerMock.UpdateVersionStaticFunc: method is nil but Storer.UpdateVersionStatic was just called")
	}
	callInfo := struct {
		Ctx            context.Context
		CurrentVersion *models.Version
		VersionUpdate  *models.Version
		ETagSelector   string
	}{
		Ctx:            ctx,
		CurrentVersion: currentVersion,
		VersionUpdate:  versionUpdate,
		ETagSelector:   eTagSelector,
	}
	mock.lockUpdateVersionStatic.Lock()
	mock.calls.UpdateVersionStatic = append(mock.calls.UpdateVersionStatic, callInfo)
	mock.lockUpdateVersionStatic.Unlock()
	return mock.UpdateVersionStaticFunc(ctx, currentVersion, versionUpdate, eTagSelector)
}

// UpdateVersionStaticCalls gets all the calls that were made to UpdateVersionStatic.
// Check the length with:
//
//	len(mockedStorer.UpdateVersionStaticCalls())
func (mock *StorerMock) UpdateVersionStaticCalls() []struct {
	Ctx            context.Context
	CurrentVersion *models.Version
	VersionUpdate  *models.Version
	ETagSelector   string
} {
	var calls []struct {
		Ctx            context.Context
		CurrentVersion *models.Version
		VersionUpdate  *models.Version
		ETagSelector   string
	}
	mock.lockUpdateVersionStatic.RLock()
	calls = mock.calls.UpdateVersionStatic
	mock.lockUpdateVersionStatic.RUnlock()
	return calls
}

// UpsertContact calls UpsertContactFunc.
func (mock *StorerMock) UpsertContact(ctx context.Context, ID string, update interface{}) error {
	if mock.UpsertContactFunc == nil {
		panic("StorerMock.UpsertContactFunc: method is nil but Storer.UpsertContact was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		ID     string
		Update interface{}
	}{
		Ctx:    ctx,
		ID:     ID,
		Update: update,
	}
	mock.lockUpsertContact.Lock()
	mock.calls.UpsertContact = append(mock.calls.UpsertContact, callInfo)
	mock.lockUpsertContact.Unlock()
	return mock.UpsertContactFunc(ctx, ID, update)
}

// UpsertContactCalls gets all the calls that were made to UpsertContact.
// Check the length with:
//
//	len(mockedStorer.UpsertContactCalls())
func (mock *StorerMock) UpsertContactCalls() []struct {
	Ctx    context.Context
	ID     string
	Update interface{}
} {
	var calls []struct {
		Ctx    context.Context
		ID     string
		Update interface{}
	}
	mock.lockUpsertContact.RLock()
	calls = mock.calls.UpsertContact
	mock.lockUpsertContact.RUnlock()
	return calls
}

// UpsertDataset calls UpsertDatasetFunc.
func (mock *StorerMock) UpsertDataset(ctx context.Context, ID string, datasetDoc *models.DatasetUpdate) error {
	if mock.UpsertDatasetFunc == nil {
		panic("StorerMock.UpsertDatasetFunc: method is nil but Storer.UpsertDataset was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		ID         string
		DatasetDoc *models.DatasetUpdate
	}{
		Ctx:        ctx,
		ID:         ID,
		DatasetDoc: datasetDoc,
	}
	mock.lockUpsertDataset.Lock()
	mock.calls.UpsertDataset = append(mock.calls.UpsertDataset, callInfo)
	mock.lockUpsertDataset.Unlock()
	return mock.UpsertDatasetFunc(ctx, ID, datasetDoc)
}

// UpsertDatasetCalls gets all the calls that were made to UpsertDataset.
// Check the length with:
//
//	len(mockedStorer.UpsertDatasetCalls())
func (mock *StorerMock) UpsertDatasetCalls() []struct {
	Ctx        context.Context
	ID         string
	DatasetDoc *models.DatasetUpdate
} {
	var calls []struct {
		Ctx        context.Context
		ID         string
		DatasetDoc *models.DatasetUpdate
	}
	mock.lockUpsertDataset.RLock()
	calls = mock.calls.UpsertDataset
	mock.lockUpsertDataset.RUnlock()
	return calls
}

// UpsertDimensionsToInstance calls UpsertDimensionsToInstanceFunc.
func (mock *StorerMock) UpsertDimensionsToInstance(ctx context.Context, dimensions []*models.CachedDimensionOption) error {
	if mock.UpsertDimensionsToInstanceFunc == nil {
		panic("StorerMock.UpsertDimensionsToInstanceFunc: method is nil but Storer.UpsertDimensionsToInstance was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		Dimensions []*models.CachedDimensionOption
	}{
		Ctx:        ctx,
		Dimensions: dimensions,
	}
	mock.lockUpsertDimensionsToInstance.Lock()
	mock.calls.UpsertDimensionsToInstance = append(mock.calls.UpsertDimensionsToInstance, callInfo)
	mock.lockUpsertDimensionsToInstance.Unlock()
	return mock.UpsertDimensionsToInstanceFunc(ctx, dimensions)
}

// UpsertDimensionsToInstanceCalls gets all the calls that were made to UpsertDimensionsToInstance.
// Check the length with:
//
//	len(mockedStorer.UpsertDimensionsToInstanceCalls())
func (mock *StorerMock) UpsertDimensionsToInstanceCalls() []struct {
	Ctx        context.Context
	Dimensions []*models.CachedDimensionOption
} {
	var calls []struct {
		Ctx        context.Context
		Dimensions []*models.CachedDimensionOption
	}
	mock.lockUpsertDimensionsToInstance.RLock()
	calls = mock.calls.UpsertDimensionsToInstance
	mock.lockUpsertDimensionsToInstance.RUnlock()
	return calls
}

// UpsertEdition calls UpsertEditionFunc.
func (mock *StorerMock) UpsertEdition(ctx context.Context, datasetID string, edition string, editionDoc *models.EditionUpdate) error {
	if mock.UpsertEditionFunc == nil {
		panic("StorerMock.UpsertEditionFunc: method is nil but Storer.UpsertEdition was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		DatasetID  string
		Edition    string
		EditionDoc *models.EditionUpdate
	}{
		Ctx:        ctx,
		DatasetID:  datasetID,
		Edition:    edition,
		EditionDoc: editionDoc,
	}
	mock.lockUpsertEdition.Lock()
	mock.calls.UpsertEdition = append(mock.calls.UpsertEdition, callInfo)
	mock.lockUpsertEdition.Unlock()
	return mock.UpsertEditionFunc(ctx, datasetID, edition, editionDoc)
}

// UpsertEditionCalls gets all the calls that were made to UpsertEdition.
// Check the length with:
//
//	len(mockedStorer.UpsertEditionCalls())
func (mock *StorerMock) UpsertEditionCalls() []struct {
	Ctx        context.Context
	DatasetID  string
	Edition    string
	EditionDoc *models.EditionUpdate
} {
	var calls []struct {
		Ctx        context.Context
		DatasetID  string
		Edition    string
		EditionDoc *models.EditionUpdate
	}
	mock.lockUpsertEdition.RLock()
	calls = mock.calls.UpsertEdition
	mock.lockUpsertEdition.RUnlock()
	return calls
}

// UpsertVersion calls UpsertVersionFunc.
func (mock *StorerMock) UpsertVersion(ctx context.Context, ID string, versionDoc *models.Version) error {
	if mock.UpsertVersionFunc == nil {
		panic("StorerMock.UpsertVersionFunc: method is nil but Storer.UpsertVersion was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		ID         string
		VersionDoc *models.Version
	}{
		Ctx:        ctx,
		ID:         ID,
		VersionDoc: versionDoc,
	}
	mock.lockUpsertVersion.Lock()
	mock.calls.UpsertVersion = append(mock.calls.UpsertVersion, callInfo)
	mock.lockUpsertVersion.Unlock()
	return mock.UpsertVersionFunc(ctx, ID, versionDoc)
}

// UpsertVersionCalls gets all the calls that were made to UpsertVersion.
// Check the length with:
//
//	len(mockedStorer.UpsertVersionCalls())
func (mock *StorerMock) UpsertVersionCalls() []struct {
	Ctx        context.Context
	ID         string
	VersionDoc *models.Version
} {
	var calls []struct {
		Ctx        context.Context
		ID         string
		VersionDoc *models.Version
	}
	mock.lockUpsertVersion.RLock()
	calls = mock.calls.UpsertVersion
	mock.lockUpsertVersion.RUnlock()
	return calls
}

// UpsertVersionStatic calls UpsertVersionStaticFunc.
func (mock *StorerMock) UpsertVersionStatic(ctx context.Context, ID string, versionDoc *models.Version) error {
	if mock.UpsertVersionStaticFunc == nil {
		panic("StorerMock.UpsertVersionStaticFunc: method is nil but Storer.UpsertVersionStatic was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		ID         string
		VersionDoc *models.Version
	}{
		Ctx:        ctx,
		ID:         ID,
		VersionDoc: versionDoc,
	}
	mock.lockUpsertVersionStatic.Lock()
	mock.calls.UpsertVersionStatic = append(mock.calls.UpsertVersionStatic, callInfo)
	mock.lockUpsertVersionStatic.Unlock()
	return mock.UpsertVersionStaticFunc(ctx, ID, versionDoc)
}

// UpsertVersionStaticCalls gets all the calls that were made to UpsertVersionStatic.
// Check the length with:
//
//	len(mockedStorer.UpsertVersionStaticCalls())
func (mock *StorerMock) UpsertVersionStaticCalls() []struct {
	Ctx        context.Context
	ID         string
	VersionDoc *models.Version
} {
	var calls []struct {
		Ctx        context.Context
		ID         string
		VersionDoc *models.Version
	}
	mock.lockUpsertVersionStatic.RLock()
	calls = mock.calls.UpsertVersionStatic
	mock.lockUpsertVersionStatic.RUnlock()
	return calls
}
